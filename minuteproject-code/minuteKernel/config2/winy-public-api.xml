<!DOCTYPE root>
<generator-config>
	<configuration>
		<conventions>
			<!-- <target-convention type="enable-updatable-code-feature" /> -->
			<target-convention type="disable-timestamp-comment-marker" />
			<target-convention type="disable-business-model-generation" />
		</conventions>
		<context class="com.winy.context.ThreadContext" init="ThreadContext.get()">
			<context-parameters>
				<context-parameter name="userId" type="int"></context-parameter>
			</context-parameters>
		</context>

		<model name="winy" version="${version}" package-root="com">
			<description>
				<CDATA>
					This model illustrates:
					Reverse-engineering on tables, views
					SDD
					Add ad-hoc forms and actions
				</CDATA>
			</description>
			<data-model database-type="MYSQL">
				<driver name="mysql" version="8.0.19" groupId="mysql"
						artifactId="mysql-connector-java"></driver>
				<dataSource>
					<driverClassName>com.mysql.cj.jdbc.Driver</driverClassName>

					<url>${jdbcUrl}</url>
					<username>${username}</username>
					<password>${password}</password>

				</dataSource>
				<!-- for Oracle and DB2 please set the schema <schema> </schema> -->
				<primaryKeyPolicy oneGlobal="true">
					<primaryKeyPolicyPattern name="autoincrementPattern"></primaryKeyPolicyPattern>
				</primaryKeyPolicy>
			</data-model>
			<statement-model>
				<enrichment>
					<conventions>
						<!-- no yet finished <sdd-pagination-convention pattern="_list" type="apply-pagination-only-to-query-ending-with" 
							add-param-default="false"/> -->
						<sdd-content-type-convention pattern="winery,badge,purchase"
													 type="apply-content-type-to-entity-not-belonging-to-package"
													 content-type="master-data" />
						<sdd-content-type-convention pattern="pay_plan,appellation,image,product,winery,badge,purchase"
													 type="apply-content-type-to-entity-not-belonging-to-package"
													 content-type="reference-data" />
						<sdd-cache-convention pattern="master-data"
											  type="apply-cache-to-content-type" />
						<sdd-cache-convention pattern="reference-data"
											  type="apply-cache-to-content-type" />
					</conventions>
				</enrichment>
				<queries>
					<!-- sitemap queries -->
					<query name="sitemap" id="sitemap"
						   package-name="sitemap">
						<query-body>
							<value>
								select * from v_sitemap order by score
							</value>
						</query-body>
						<query-schedulers><!-- schedulers are actions + scheduling and reporting 
								=> extends action -->
							<!--
* "0 0 * * * *" = the top of every hour of every day.
* "*/10 * * * * *" = every ten seconds.
* "0 0 8-10 * * *" = 8, 9 and 10 o'clock of every day.
* "0 0 8,10 * * *" = 8 and 10 o'clock of every day.
* "0 0/30 8-10 * * *" = 8:00, 8:30, 9:00, 9:30 and 10 o'clock every day.
* "0 0 9-17 * * MON-FRI" = on the hour nine-to-five weekdays
* "0 0 0 25 12 ?" = every Christmas Day at midnight
-->
							<query-scheduler name="process_sitemap"
											 cron="0 1 1 * * ?" report-channel="mailgun" report-from="thewineryproject@gmail.com"
											 report-to="thewineryproject@gmail.com"
											 report-threshold-min-record="1"
											 report-template-type="velocity"
											 report-template-name="sitemap.xml.vm">
							</query-scheduler>
						</query-schedulers>
					</query>

					<!-- event -->
					<query name="has_event_ownership" id="has_event_ownership"
						   package-name="event">
						<query-body>
							<!-- TODO check if ppp has option scan -->
							<value>
								select exists(
								select u.email,
								e.web_path
								from
								event e,
								event_organiser eo,
								user_event_organiser_profile ueop,
								profile_pay_plan ppp,
								user u
								where
								e.event_organiser_id = eo.id
								and ueop.event_organiser_id = eo.id
								and ueop.profile_pay_plan_id = ppp.id
								and ueop.user_id = u.id
								$whereEventWebPath
								$whereUserEmail
								)
								as has_event_ownership
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEventWebPath"
										  and-where-connection="and">
								<value><![CDATA[ e.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'-1'" mandatory="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereUserEmail"
										  and-where-connection="and">
								<value><![CDATA[ u.email = ? ]]></value>
								<query-params>
									<query-param name="user_email" type="string"
												 sample="'-1'" mandatory="true" scope="backend">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="has_winery_event_ownership" id="has_winery_event_ownership"
						   package-name="event">
						<query-body>
							<value>
								select exists(
								select u.email,
								w.web_path,
								e.web_path
								from
								event_winery_participation evp,
								event e,
								winery w,
								user_winery_profile uwp,
								profile_pay_plan ppp,
								user u
								where
								evp.winery_id = w.id
								and evp.event_id = e.id
								and uwp.winery_id = w.id
								and uwp.profile_pay_plan_id = ppp.id
								and uwp.user_id = u.id
								$whereEventWebPath
								$whereWineryWebPath
								$whereUserEmail
								)
								as has_winery_event_ownership
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEventWebPath"
										  and-where-connection="and">
								<value><![CDATA[ e.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'-1'" mandatory="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryWebPath"
										  and-where-connection="and">
								<value><![CDATA[ w.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string"
												 sample="'-1'" mandatory="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereUserEmail"
										  and-where-connection="and">
								<value><![CDATA[ u.email = ? ]]></value>
								<query-params>
									<query-param name="user_email" type="string"
												 sample="'-1'" mandatory="true" scope="backend">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- event info, winery participation, partner, wine -->

					<!-- todo add logo, images -->
					<query name="event_summary" id="event_summary" package-name="event">
						<query-body>
							<value>
								select
								sum(NB_PAST_EVENTS) NB_PAST_EVENTS,
								sum(NB_CURRENT_EVENTS) NB_CURRENT_EVENTS,
								sum(NB_FUTURE_EVENTS) NB_FUTURE_EVENTS,
								VENUE_COUNTRY_NAME,
								VENUE_COUNTRY_WEB_PATH
								from
								(
								select
								case when timeline = 'PAST' then nb_of_events end as NB_PAST_EVENTS,
								case when timeline = 'CURRENT' then nb_of_events end as NB_CURRENT_EVENTS,
								case when timeline = 'FUTURE' then nb_of_events end as NB_FUTURE_EVENTS,
								VENUE_COUNTRY_NAME,
								VENUE_COUNTRY_WEB_PATH
								from (
								select
								count(*) as nb_of_events,
								VENUE_COUNTRY_NAME,
								VENUE_COUNTRY_WEB_PATH,
								TIMELINE
								from
								v_event_public vep
								$whereEventWebPath
								$whereCountryWebPath
								$whereTimeline
								group by VENUE_COUNTRY_NAME, VENUE_COUNTRY_WEB_PATH, TIMELINE
								) xxx
								) yyy group by VENUE_COUNTRY_NAME, VENUE_COUNTRY_WEB_PATH
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEventWebPath"
										  and-where-connection="where">
								<value><![CDATA[ vep.EVENT_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereCountryWebPath"
										  and-where-connection="where">
								<value><![CDATA[ vep.VENUE_COUNTRY_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="country_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTimeline"
										  and-where-connection="where">
								<value><![CDATA[ TIMELINE = ? ]]></value>
								<query-params>
									<query-param name="timeline" type="string" sample="'FUTURE'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="event_info" id="event_info" package-name="event">
						<query-body>
							<value>
								select
								ID EVENT_ID,
								IS_ACTIVE,
								YEAR,
								WEBSITE,
								TAGS,
								IS_BIO,
								GEOLOC_MAP_LONGITUDE,
								GEOLOC_MAP_LATITUDE,
								GEOLOC_MAP_GOOGLE_ZOOM,
								EDITION_NUMBER,
								ENTRANCE_FEE,
								ENTRANCE_FEE_PRESALE,
								IS_GLASS_INCLUDED_IN_PRICE,
								GLASS_PRICE,
								PRESALE_FEE_NB_DAYS_BEFORE_EVENT,
								FREE_UNDER_AGE,
								NB_OF_WINERIES,
								NB_OF_EXHIBITORS,
								EVENT_WEB_PATH,
								EVENT_NAME,
								FROM_DATE,
								TO_DATE,
								FROM_TIME,
								TO_TIME,
								TIMELINE,
								DESCRIPTION,
								HAS_PURCHASE_ORDER,
								EMAIL,
								ORGANISOR_NAME,
								VENUE_NAME,
								VENUE_COUNTRY_NAME,
								VENUE_COUNTRY_WEB_PATH,
								VENUE_STREET1,
								VENUE_STREET2,
								VENUE_POST_CODE,
								VENUE_CITY,
								VENUE_MAIL,
								VENUE_TELEPHONE,
								social_network_details,
								case when logo_id is not null then true else false end has_logo,
								case when img_id is not null then true else false end has_image,
								nb_of_wineries_per_region,
								nb_of_wineries_per_country,
								opening_hours
								from
								v_event_public vep
								$whereEventWebPath
								$whereCountryWebPath
								$whereEventIds
								$whereTimeline
								$whereStartDateGreaterThan
								$whereActive
								$order_by
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEventWebPath"
										  and-where-connection="where">
								<value><![CDATA[ vep.EVENT_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereCountryWebPath"
										  and-where-connection="where">
								<value><![CDATA[ vep.VENUE_COUNTRY_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="country_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventIds"
										  and-where-connection="where">
								<value><![CDATA[ vep.ID in (?...) ]]></value>
								<query-params>
									<query-param name="event_ids" type="int" sample="1,2" is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTimeline"
										  and-where-connection="where">
								<value><![CDATA[ vep.TIMELINE in (?...) ]]></value>
								<query-params>
									<query-param name="timeline" type="string" sample="'FUTURE','CURRENT'" is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereStartDateGreaterThan"
										  and-where-connection="where">
								<value><![CDATA[ vep.FROM_DATE > ? ]]></value>
								<query-params>
									<query-param name="from_date_greater_than" type="date" sample="current_date()">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereActive"
										  and-where-connection="where">
								<value><![CDATA[ vep.IS_ACTIVE = ? ]]></value>
								<query-params>
									<query-param name="is_active" type="boolean" sample="true">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-chunks>
							<query-chunk name="order_by"
										 sample-value="order by FROM_DATE desc" >
								<query-chunk-value name="from_date_desc" value="order by FROM_DATE desc" />
								<query-chunk-value name="from_date_asc" value="order by FROM_DATE asc" is-default="true" />
							</query-chunk>
						</query-chunks>
						<query-pagination max-result-param="limit"
										  offset-param="offset"></query-pagination>
					</query>
					<query name="event_wine_price_item" id="event_wine_price_item"
						   package-name="event">
						<query-body>
							<!-- TODO add filters color, bubbleness, ... -->
							<value>
								select
								pip.ID PRODUCT_ITEM_PRICE_ID,
								e.ID EVENT_ID,
								e.WEB_PATH EVENT_WEB_PATH,
								e.NAME EVENT_NAME,
								from_date - INTERVAL ifnull(ewp.nb_of_day_presale_before_event,10) DAY > now() is_presale,
								TO_DATE + INTERVAL 1 DAY > now() is_under_event_price,
								pipxe.PRICE event_price,
								pipxe.PRE_ORDER_PRICE EVENT_PRE_ORDER_PRICE,
								pip.price home_price,
								round(pipxe.PRICE / pip.PRICE * 100, 0) - 100 home_to_event_price_inc_perc,
								round(pipxe.PRE_ORDER_PRICE / pip.PRICE * 100, 0) - 100 home_to_pre_order_price_inc_perc,
								pip.quantity,
								pip.year year,
								pip.valid_from price_valid_from,
								pip.valid_until price_valid_until,
								pip.creation_date,
								pip.last_modification,
								cu.name currency_name,
								cu.class_name currency_class_name,
								w.name winery,
								r.name region,
								c.name country,
								c.web_path country_web_path,
								c.flag_icon country_flag_icon,
								w.web_path winery_web_path,
								p.web_path product_web_path
								,p.id product_id
								,p.name product_name
								,p.is_bio is_bio
								,p.sweetness
								,p.puissance
								,p.bubbleness
								,case when product_logo_id is not null then true else false end has_product_logo,
								case when product_image_id is not null then true else false end has_product_image,
								case when technical_sheet_id is not null then true else false end has_product_technical_sheet,
								case when winery_logo_id is not null then true else false end has_winery_logo,
								w.id winery_id,
								pc.name color_name,
								pc.rgb color_rgb,
								pc.name product_color_name,
								pc.rgb product_color_rgb,
								wvu.name wine_recipient_name,
								wvu.web_path wine_recipient_web_path,
								wvu.VOLUME_IN_ML wine_recipient_volume_in_ml,
								wvu.ICON_CLASS wine_recipient_icon_class,
								wld.label_details winery_label_details,
								pld.label_details product_label_details,
								pxc.cepage_id_names cepage_id_names,
								pxc.cepage_id_names cepage_id_name_percents,
								a.name appellation_details,
								a.name appellation_name,
								ac.name appellation_classification_name,
								ac.acronym appellation_classification_acronym,
								a.web_path appellation_web_path,
								ewp.nb_of_day_presale_before_event,
								ewp.show_home_presale_price_delta,
								ewp.show_home_event_price_delta,
								ewp.presale_payment_in_advance,
								ewp.booth,
								ewp.participation_level

								from
								PRODUCT_ITEM_PRICE_X_EVENT pipxe,
								EVENT e,
								PRODUCT_ITEM_PRICE pip,
								PRODUCT p
								LEFT OUTER JOIN (
								SELECT min(entity_id) product_logo_id
								FROM
								picture_entity_value
								where
								entity = 'product' AND sub_type = 'logo'
								group by entity_id
								) pl on p.id = pl.product_logo_id
								LEFT OUTER JOIN (
								SELECT min(entity_id) product_image_id
								FROM
								picture_entity_value
								where
								entity = 'product' AND sub_type = 'default'
								group by entity_id
								) p3 on p.id = p3.product_image_id
								LEFT OUTER JOIN (
								SELECT min(entity_id) technical_sheet_id
								FROM
								picture_entity_value
								where
								entity = 'product' AND sub_type = 'technical_sheet'
								group by entity_id
								) p2 on p.id = p2.technical_sheet_id
								LEFT OUTER JOIN (
								select lxp.product_id,
								GROUP_CONCAT(
								CONCAT_WS(
								'|',
								l.id, l.name, l.web_path, l.code
								)
								order by lxp.display_order
								) label_details
								from REF_LABEL_X_PRODUCT lxp, ref_label l
								where lxp.label_id = l.id
								) pld on pld.product_id = p.id
								LEFT OUTER JOIN
								ref_appelation a ON p.appelation_id = a.id
								LEFT OUTER JOIN
								ref_appelation_classification ac ON a.ref_appelation_classification_id = ac.id
								left outer join (
								select pxc.product_id ,
								GROUP_CONCAT(DISTINCT ce.id,',', ce.name SEPARATOR '|') cepage_id_names
								from product_x_cepage pxc, cepage ce
								where pxc.cepage_id = ce.id
								group by pxc.product_id
								) pxc on pxc.product_id = p.id
								,
								winery w
								LEFT OUTER JOIN (
								SELECT min(entity_id) winery_logo_id
								FROM
								picture_entity_value
								where
								entity = 'winery' AND sub_type = 'logo'
								group by entity_id
								) wl on w.id = wl.winery_logo_id
								LEFT OUTER JOIN (
								select lxw.winery_id,
								GROUP_CONCAT(
								CONCAT_WS(
								'|',
								l.id, l.name, l.web_path, l.code
								)
								order by lxw.display_order
								) label_details
								from REF_LABEL_X_WINERY lxw, ref_label l
								where lxw.label_id = l.id
								) wld on wld.winery_id = w.id
								,
								region r,
								country c,
								ref_currency cu,
								color pc,
								REF_WINE_VOLUME_UNIT wvu,
								EVENT_WINERY_PARTICIPATION ewp

								where pipxe.PRODUCT_ITEM_PRICE_ID = pip.id
								and pipxe.EVENT_ID = e.ID
								and pip.PRODUCT_ID = p.ID
								and pip.WINE_VOLUME_UNIT_ID = wvu.ID
								and p.winery_id = w.id
								and w.region_id = r.id
								and p.color_id = pc.id
								and r.country_id = c.id
								and c.currency_id = cu.id
								and ewp.event_id = e.ID
								and ewp.winery_id = w.id
								and	p.active = 1
								and w.active = 1
								and pip.active = 1
								and e.active = 1

								$scope
								$whereEventWebPath
								$whereWineryWebPath
								$whereEventId
								$whereWineryId
								$whereProductItemPriceId
							</value>
						</query-body>
						<query-chunks>
							<query-chunk name="scope"
										 sample-value="and TO_DATE + INTERVAL 1 DAY > now()"
										 >
								<query-chunk-value name="under_event_price"
												   value="and TO_DATE + INTERVAL 1 DAY > now()"/>
								<query-chunk-value name="after_event_price"
												   value="and now() > TO_DATE + INTERVAL 1 DAY "/>
								<query-chunk-value name="event_presale_price"
												   value="and from_date - INTERVAL ifnull(ewp.nb_of_day_presale_before_event,10) DAY > now()"/>
								<!-- event price is under_event_price but not event_presale_price -->
								<query-chunk-value name="event_price"
												   value="and now() > from_date - INTERVAL ifnull(ewp.nb_of_day_presale_before_event,10) DAY and TO_DATE + INTERVAL 1 DAY > now()"/>
								<query-chunk-value name="all"
												   value="" is-default="true" />
							</query-chunk>
						</query-chunks>
						<query-filters>
							<query-filter name="whereEventWebPath" and-where-connection="and">
								<value><![CDATA[ e.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryWebPath" and-where-connection="and">
								<value><![CDATA[ w.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventId" and-where-connection="and">
								<value><![CDATA[ e.ID = ? ]]></value>
								<query-params>
									<query-param name="event_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryId" and-where-connection="and">
								<value><![CDATA[ w.ID = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereProductItemPriceId" and-where-connection="and">
								<value><![CDATA[ pip.id = ? ]]></value>
								<query-params>
									<query-param name="product_item_price_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="winery_timetable_info" id="winery_timetable_info"
						   package-name="winery">
						<query-body>
							<!-- TODO add filters color, bubbleness, ... -->
							<value>
								select
								w.web_path winery_web_path
								,w.id winery_id
								,vt.description timetable_description
								,vts.week_day
								,vts.day_meridium
								,vts.time_start_hour
								,vts.time_start_minute
								,vts.time_end_hour
								,vts.time_end_minute
								from visit_timetable vt, visit_timetable_schedule vts, winery w
								where vts.visit_timetable_id = vt.id and vt.winery_id = w.id
								$whereWineryWebPath
								$whereWineryId
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereWineryWebPath" and-where-connection="and">
								<value><![CDATA[ w.web_path = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryId" and-where-connection="and">
								<value><![CDATA[ w.id = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>
					<query name="winery_shipping_cost" id="winery_shipping_cost"
						   package-name="winery">
						<query-body>
							<!-- TODO add filters color, bubbleness, ... -->
							<value>
								select w.id winery_id,
								w.name winery_name,
								w.web_path winery_web_path,
								co.name country_origin_name,
								co.web_path country_origin_web_path,
								ct.name country_target_name,
								ct.web_path country_target_web_path,
								cw.name country_winery_name,
								case when ct.id = co.id and ct.id = cw.id then 1 else 0 end inside_country,
								wsc.quantity,
								wsc.price,
								cu.name currency_name,
								cu.web_path currency_web_path,
								cu.class_name currency_html_entity,
								wvu.name volume_name,
								wvu.volume_in_ml volume_in_ml
								from winery_shipping_cost wsc,
								shipping_trip st,
								country co,
								country ct,
								ref_currency cu,
								ref_wine_volume_unit wvu,
								winery w,
								region r,
								country cw
								where wsc.winery_id = w.id
								and wsc.shipping_trip_id = st.id
								and st.country_origin_id = co.id
								and st.country_target_id = ct.id
								and wsc.wine_volume_unit_id = wvu.id
								and wsc.currency_id = cu.id
								and w.region_id = r.id
								and r.country_id = cw.id
								$whereWineryWebPath
								$whereWineryId
								order by co.name, ct.name, wvu.volume_in_ml, wsc.quantity
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereWineryWebPath" and-where-connection="and">
								<value><![CDATA[ w.web_path = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryId" and-where-connection="and">
								<value><![CDATA[ w.id = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>
					<query name="winery_wine_price_item" id="winery_wine_price_item"
						   package-name="winery">
						<query-body>
							<!-- TODO add filters color, bubbleness, ... -->
							<value>
								select
								ID PRODUCT_ITEM_PRICE_ID,
								home_price,
								quantity,
								year,
								price_valid_from,
								price_valid_until,
								creation_date,
								last_modification,
								currency_name,
								currency_class_name,
								winery,
								region,
								winery_web_path,
								country,
								country_web_path,
								country_flag_icon,
								product_web_path,
								has_product_logo,
								has_product_image,
								has_winery_logo,
								has_product_technical_sheet,
								winery_id,
								product_id,
								product_name,
								is_bio,
								product_color_name color_name,
								product_color_rgb color_rgb,
								product_color_name,
								product_color_rgb,
								sweetness,
								puissance,
								bubbleness,
								wine_recipient_name,
								wine_recipient_web_path,
								wine_recipient_icon_class,
								wine_recipient_volume_in_ml,
								winery_label_details,
								product_label_details,
								appellation_details,
								appellation_name,
								appellation_classification_name,
								appellation_classification_acronym,
								appellation_web_path,
								cepage_id_names,
								cepage_id_name_percents
								from v_winery_wine_price_item
								$whereWineryWebPath
								$whereWineryId
								$whereProductItemPriceId
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereWineryWebPath" and-where-connection="where">
								<value><![CDATA[ winery_web_path = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string" sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryId" and-where-connection="where">
								<value><![CDATA[ winery_id = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereProductItemPriceId" and-where-connection="where">
								<value><![CDATA[ id = ? ]]></value>
								<query-params>
									<query-param name="product_item_price_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>

					<query name="event_organiser_winery_participation" id="event_organiser_winery_participation"
						   package-name="event">
						<query-body>
							<value>
								<![CDATA[
select zzz.event_organiser_id, zzz.event_organiser_name, 
zzz.event_id, zzz.event_name, zzz.winery_id, zzz.event_web_path,
zzz.from_date, zzz.to_date, zzz.event_year,
zzz.winery_name, zzz.longitude, zzz.latitude, xxx.score 
from (
        select eo.id event_organiser_id,
	        eo.name event_organiser_name,
	        e.id event_id, 
	        e.name event_name, 
	        e.web_path event_web_path,
	        e.from_date,
	        e.to_date,
	        e.year event_year,
	        w.id winery_id, 
	        w.name winery_name, 
	        w.longitude, 
	        w.latitude 
        from event_winery_participation ewp, event e, event_organiser eo,  winery w
        where ewp.event_id = e.id and ewp.winery_id = w.id and e.event_organiser_id = eo.id 
        group by eo.id, e.id, w.id

) zzz left outer join
(
        select eo.id event_organiser_id, 
	        e.id event_id, 
	        w.id winery_id, 
	        count(r.id) as score from reward r, 
	        event e, 
	        event_organiser eo, 
	        product_item pi, 
	        product p, 
	        winery w
        where pi.product_id = p.id and p.winery_id = w.id and r.event_id = e.id and r.product_item_id = pi.id and e.event_organiser_id = eo.id
        group by eo.id, e.id, w.id
) xxx on xxx.event_organiser_id=zzz.event_organiser_id and xxx.event_id =zzz.event_id  and xxx.winery_id = zzz.winery_id
$whereEventId $whereEventWebPath $whereEventOrganiserId $whereWineryId 
      	]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEventId"
										  and-where-connection="where">
								<value><![CDATA[ zzz.event_id = ? ]]></value>
								<query-params>
									<query-param name="event_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventWebPath"
										  and-where-connection="where">
								<value><![CDATA[ zzz.event_web_path = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventOrganiserId"
										  and-where-connection="where">
								<value><![CDATA[ zzz.event_organiser_id = ? ]]></value>
								<query-params>
									<query-param name="event_organiser_id" type="int"
												 sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryId"
										  and-where-connection="where">
								<value><![CDATA[ zzz.winery_id = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-pivots>
							<query-pivot name="event_organiser"
										 columns="event_organiser_id,event_organiser_name" pivot="event_organiser_id"></query-pivot>
							<query-pivot name="event"
										 columns="event_id,event_name,event_web_path" pivot="event_id"></query-pivot>
							<query-pivot name="winery" columns="winery_id,winery_name"
										 pivot="winery_id"></query-pivot>
						</query-pivots>
					</query>

					<query name="partners_for_event" id="partners_for_event"
						   package-name="event">
						<query-body>
							<value>
								<![CDATA[
select ep.id id, 
	ep.name name, 
	ep.web_path web_path,
	ep.partnership_level partnership_level,
	ep.web_site web_site,
	case when logo.logo_id is not null then true else false end has_logo
from 
	event_partner ep
	LEFT OUTER JOIN (
		SELECT min(entity_id) logo_id
		FROM
			picture_entity_value
		where
			entity = 'partner' AND sub_type = 'logo'
		    group by entity_id
	) logo on ep.id = logo.logo_id
	, event e
where ep.event_id = e.id
$whereeventwebpath
and e.active = 1
order by partnership_level desc
	]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereeventwebpath"
										  and-where-connection="and">
								<value><![CDATA[ e.web_path = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="participants_for_event" id="participants_for_event"
						   package-name="event">
						<query-body>
							<value>
								<![CDATA[
select 
	ewp.id ewp_Id, 
	participation_level ewp_participation_level, 
	booth ewp_booth, 
	registration_date ewp_registration_date,
	ewp.nb_of_day_presale_before_event,
	e.from_date - INTERVAL ifnull(ewp.nb_of_day_presale_before_event,10) DAY > now() is_presale,
	e.TO_DATE + INTERVAL 1 DAY > now() is_under_event_price,
	w.name domain, 
	w.web_path winery_web_path,
	e.name event,
	e.web_path event_web_path
from 
	event_winery_participation ewp, 
	winery w, 
	event e
where 
	ewp.event_id = e.id 
	and ewp.winery_id = w.id
	and ewp.active = 1
$whereeventactive 
$whereewineryactive
$whereeventwebpath 
$wherewinerywebpath
order by 
	e.from_date desc, 
	ewp_participation_level desc
	]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereeventactive"
										  and-where-connection="and">
								<value><![CDATA[ e.active = ? ]]></value>
								<query-params>
									<query-param name="event_is_active" type="boolean" sample="true" default-value="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereewineryactive"
										  and-where-connection="and">
								<value><![CDATA[ w.active = ? ]]></value>
								<query-params>
									<query-param name="winery_is_active" type="boolean" sample="true" default-value="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereeventwebpath"
										  and-where-connection="and">
								<value><![CDATA[ e.web_path = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewinerywebpath"
										  and-where-connection="and">
								<value><![CDATA[ w.web_path = ? ]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- end event -->
					<!-- user security -->
					<query name="user_info" id="user_info" package-name="user"
						   scope="backend">
						<query-body>
							<value>
								select
								user_id,
								email,
								user_name,
								gender,
								encode_pass,
								first_name,
								last_name,
								street1,
								street2,
								city,
								zip,
								country,
								language
								from v_user_details
								where email = ? or user_name = ?
							</value>
						</query-body>
						<query-params>
							<query-param name="email" type="string" sample="'1'">
							</query-param>
							<query-param name="username" refname="email" sample="'1'">
							</query-param>
						</query-params>
					</query>

					<query name="user_purchase_order" id="user_purchase_order"
						   package-name="user" scope="backend">
						<query-body>
							<value>
								select
								login,
								po_key,
								create_time,
								type,
								status,
								json,
								po.id purchase_order_id
								from po_customer cus, po_purchase_order po
								where cus.id =
								po.customer_id
								$whereemail
								$wheretype
								$wherestatus
								order by
								create_time desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereemail"
										  and-where-connection="and">
								<value>
									<![CDATA[ login = ? ]]>
								</value>
								<query-params>
									<query-param name="email" type="string" sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wheretype" and-where-connection="and">
								<value>
									<![CDATA[ type = ? ]]>
								</value>
								<query-params>
									<query-param name="type" type="string" sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherestatus"
										  and-where-connection="and">
								<value>
									<![CDATA[ status = ? ]]>
								</value>
								<query-params>
									<query-param name="status" type="string" sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- purchase order -->
					<query name="store_purchase_order" id="store_purchase_order"
						   package-name="purchase" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call store_purchase_order (?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="login" is-mandatory="true" type="string"
										 sample="'win'">
								<validations>
									<validation-pattern type="email" regex="" />
								</validations>
							</query-param>
							<query-param name="gender" is-mandatory="true" type="string"
										 sample="'MALE'">
							</query-param>
							<query-param name="first_name" is-mandatory="true" type="string"
										 sample="'test'">
							</query-param>
							<query-param name="last_name" is-mandatory="true" type="string"
										 sample="'test'">
							</query-param>
							<query-param name="language_code" is-mandatory="true" type="string"
										 sample="'FR'">
							</query-param>
							<query-param name="json" is-mandatory="true" type="string"
										 sample="'win'">
							</query-param>
							<query-param name="key" is-mandatory="true" type="string"
										 is-output-param="true" sample="'win'"></query-param>
						</query-params>
					</query>

					<query name="confirm_purchase_order" id="confirm_purchase_order"
						   package-name="purchase" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call confirm_purchase_order (?, ?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="login" is-mandatory="true" type="string"
										 sample="'win'">
								<validations>
									<validation-pattern type="email" regex="" />
								</validations>
							</query-param>
							<query-param name="gender" is-mandatory="true" type="string"
										 sample="'MALE'">
							</query-param>
							<query-param name="first_name" is-mandatory="true" type="string"
										 sample="'test'">
							</query-param>
							<query-param name="last_name" is-mandatory="true" type="string"
										 sample="'test'">
							</query-param>
							<query-param name="language_code" is-mandatory="true" type="string"
										 sample="'FR'">
							</query-param>
							<query-param name="key" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="json" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="status" is-mandatory="true" type="string"
										 sample="'win'" is-output-param="true"></query-param>
						</query-params>
					</query>

					<query name="process_purchase_order" id="process_purchase_order"
						   package-name="purchase" is-write="true" scope="backend">
						<!-- TODO remove kendoui artifact when scope=backend -->
						<query-body>
							<value>
								<![CDATA[
call process_purchase_order (?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="purchase_order_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
					</query>

					<query name="lookup_purchase_order_to_process" id="lookup_purchase_order_to_process"
						   package-name="purchase" scope="backend">
						<query-body>
							<value>
								<![CDATA[
select 
	ppo.ID,
 	ppo.CUSTOMER_ID,
 	ppo.LANGUAGE_CODE,
 	ppo.PO_KEY,
 	ppo.CREATE_TIME,
 	ppo.TYPE,
 	ppo.STATUS,
 	ppo.JSON,
 	pc.LOGIN CUSTOMER_LOGIN,
 	pc.GENDER,
 	pc.NAME,
 	pc.FIRST_NAME,
 	pc.LAST_NAME,
 	pc.STREET1,
 	pc.STREET2,
 	pc.POST_CODE,
 	pc.CITY,
 	pc.COUNTRY
from 
	PO_PURCHASE_ORDER ppo, PO_CUSTOMER pc 
where ppo.CUSTOMER_ID = pc.ID and ppo.status = 'CONFIRMED'
	]]>
							</value>
						</query-body>
						<query-schedulers><!-- schedulers are actions + scheduling and reporting 
								=> extends action -->
							<query-scheduler name="process_purchase_order"
											 cron="0 0 15 * * *" report-channel="mailgun" report-from="thewineryproject@gmail.com"
											 report-to="thewineryproject@gmail.com"
											 report-threshold-min-record="1"
											 report-template-type="velocity"
											 report-template-name="process_purchase_order.vm">
								<actions>
									<action name="process_purchase_order" query-id="process_purchase_order">
										<action-field-map>
											<action-field-map-entry output-field="id"
																	to-action-field="purchase_order_id" />
										</action-field-map>
									</action>
								</actions>
							</query-scheduler>
						</query-schedulers>
					</query>

					<!-- purchase order end -->

					<query name="send_description_post" id="send_description_post"
						   package-name="post" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call send_description_post (?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'win'">
								<validations>
									<validation-pattern type="email" regex="" />
								</validations>
							</query-param>
							<query-param name="entity_type" is-mandatory="true"
										 type="string" sample="'win'">
								<validations>
									<validation-among-values
											values="winery,wine,region,country,lieu_dit,grape" error="Entity type is not correct" />
									<validation-exist-in-list query-id="distinct_allowed_entities"
															  error="Entity type is not correct" />
								</validations>
							</query-param>
							<query-param name="entity_value" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'win'">
								<validations>
									<validation-exist-unique query-id="only_one_value_for_language_code"
															 error="language does not exist" />
								</validations>
							</query-param>
							<query-param name="description" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="ip" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
						</query-params>
					</query>

					<query name="send_feedback_post" id="send_feedback_post"
						   package-name="post" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call send_feedback_post (?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="category" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="comments" is-mandatory="true"
										 type="string" sample="'win'">
								<validations>
									<validation-range-char min='10' />
								</validations>
							</query-param>
							<query-param name="origin" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="origin_url" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'win'">
								<validations>
									<validation-exist-unique query="only_one_value_for_language_code"
															 error="language does not exist" />
								</validations>
							</query-param>
							<query-param name="ip" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
						</query-params>
					</query>

					<query name="send_domain_inscription_post" id="send_domain_inscription_post"
						   package-name="post" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call send_domain_inscription_post (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="pay_plan_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="pay_plan_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="first_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="last_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="domain" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="country_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="country_name" is-mandatory="true"
										 type="string" sample="1"></query-param>
							<query-param name="region_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="region_name" is-mandatory="true"
										 type="string" sample="1"></query-param>
							<query-param name="lieu_dit_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="lieu_dit_name" is-mandatory="true"
										 type="string" sample="1"></query-param>
							<query-param name="grape_ids" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="grape_names" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="description" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="ip" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
						</query-params>
						<!-- sample security validation -->
						<query-validations>
							<!-- implicit connected user -->
							<validation-exist-unique query="can_perform_inscription"
													 query-params="user,entity,context" error="cannot register" />
						</query-validations>
					</query>

					<query name="send_domain_with_address_inscription_post" id="send_domain_with_address_inscription_post"
						   package-name="post" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call send_domain_with_address_inscription_post (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="pay_plan_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="pay_plan_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="first_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="last_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="domain" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="country_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="country_name" is-mandatory="true"
										 type="string" sample="1"></query-param>
							<query-param name="region_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="region_name" is-mandatory="true"
										 type="string" sample="1"></query-param>
							<query-param name="lieu_dit_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="lieu_dit_name" is-mandatory="true"
										 type="string" sample="1"></query-param>

							<query-param name="street1" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="street2" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="place" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="state" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="state_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="postCode" is-mandatory="true"
										 type="int" sample="1"></query-param>

							<query-param name="grape_ids" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="grape_names" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="description" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="ip" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
						</query-params>
						<!-- sample security validation -->
						<query-validations>
							<!-- implicit connected user -->
							<validation-exist-unique query-id="can_perform_inscription"
													 query-params="user,entity,context" error="cannot register" />
						</query-validations>
					</query>


					<query name="send_event_request_post" id="send_event_request_post"
						   package-name="post" is-write="true">
						<query-body>
							<value>
								<![CDATA[
call send_event_request_post (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="first_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="last_name" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="event" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
							<query-param name="country_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="country_name" is-mandatory="true"
										 type="string" sample="1"></query-param>

							<query-param name="start_date" is-mandatory="true"
										 type="date" sample="1"></query-param>
							<query-param name="end_date" is-mandatory="true"
										 type="date" sample="1"></query-param>

							<query-param name="street1" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="street2" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="place" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="state" is-mandatory="true" type="string"
										 sample="'1'"></query-param>
							<query-param name="state_id" is-mandatory="true"
										 type="int" sample="1"></query-param>
							<query-param name="postCode" is-mandatory="true"
										 type="int" sample="1"></query-param>

							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="description" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="ip" is-mandatory="true" type="string"
										 sample="'win'"></query-param>
						</query-params>
						<!-- sample security validation -->
						<query-validations>
							<!-- implicit connected user -->
							<validation-exist-unique query-id="can_perform_inscription"
													 query-params="user,entity,context" error="cannot register" />
						</query-validations>
					</query>

					<query name="store_post_entity_process" id="store_post_entity_process"
						   package-name="post" is-write="true" scope="backend">
						<!-- TODO remove kendoui artifact when scope=backend -->
						<query-body>
							<value>
								<![CDATA[
call update_post_entity_to_processed (?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="post_entity_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
					</query>
					<query name="lookup_post_to_process" id="lookup_post_to_process"
						   package-name="post" scope="backend">
						<query-body>
							<value>
								<![CDATA[
select * from post_entity where status = 'TO_PROCESS'
	]]>
							</value>
						</query-body>
						<query-schedulers><!-- schedulers are actions + scheduling and reporting 
								=> extends action -->
							<query-scheduler name="process_post_entities"
											 cron="0 30 8 * * *,0 0 16 * * *" report-channel="mailgun"
											 report-from="thewineryproject@gmail.com" report-to="thewineryproject@gmail.com"
											 report-threshold-min-record="1">
								<actions>
									<action name="store_post_entity_process" query-id="store_post_entity_process">
										<action-field-map>
											<action-field-map-entry output-field="id"
																	to-action-field="post_entity_id" />
										</action-field-map>
									</action>
								</actions>
							</query-scheduler>
						</query-schedulers>
					</query>

					<!-- color -->
					<query name="color_info" id="color_info" package-name="color"
						   content-type="reference-data">
						<query-body>
							<!--  select SQL_CACHE seems not to work in mysql V8 -->
							<value>
								select
								c.name name,
								c.rgb rgb,
								c.base_color
								is_base_color,
								c.is_robe_color,
								c.display_order,
								p.name
								parent_color_name,
								p.rgb parent_color_rgb
								from color c left outer
								join color p on c.parent_color_id = p.id
								order by c.display_order
							</value>
						</query-body>
					</query>
					<!-- cepage/grape color -->
					<query name="distinct_color_per_appellation" id="distinct_color_per_appellation"
						   package-name="color" content-type="reference-data">
						<query-body>
							<value>
								select distinct co.name, co.rgb rgb from color co,
								ref_appelation a
								where a.color_id = co.id
							</value>
						</query-body>
					</query>
					<query name="distinct_color_per_grape" id="distinct_color_per_grape"
						   package-name="color" content-type="reference-data">
						<query-body>
							<value>
								select distinct co.name, co.rgb rgb from color co, cepage
								c
								where c.color_id = co.id
							</value>
						</query-body>
					</query>
					<query name="distinct_color_per_product" id="distinct_color_per_product"
						   package-name="color" content-type="reference-data">
						<query-body>
							<value>
								select distinct co.name, co.rgb rgb from color co, product
								p
								where p.color_id = co.id
							</value>
						</query-body>
					</query>

					<!-- post package end -->
					<!-- not part of public api <query name="winery_profile" id="winery_profile" 
						package-name="profile"> <query-body> <value> select w.id domain_id, w.name 
						domain, ppp.pay_plan_name formula, ppp.pay_plan_price price, ppp.register_date 
						register_date, ppp.activation_date activation_date, ppp.end_activation_date 
						end_activation_date, r.name region from user u, user_winery_profile uwp, 
						winery w, profile_pay_plan ppp, region r where uwp.user_id = u.id and uwp.winery_id 
						= w.id and uwp.profile_pay_plan_id = ppp.id and w.region_id = r.id and u.email 
						= ? </value> </query-body> <query-params> <query-param name="email" is-mandatory="true" 
						type="string" sample="'mail'"></query-param> </query-params> </query> -->
					<!-- TODO add filter wherelieuditwebpath -->
					<query name="appelation_badge" id="appelation_badge"
						   package-name="appellation">
						<query-body>
							<value>
								select a.id,
								a.name,
								a.web_path,
								r.name region_name,
								r.web_path region_web_path,
								coun.name country_name,
								coun.web_path
								country_web_path,
								coun.flag_icon country_flag_icon,
								a.description,
								a.url_description,
								a.is_related_to_place,
								a.is_related_to_product,
								a.sweetness,
								a.bubbleness,
								a.alias,
								a.last_modification,
								a.alcohol_min,
								a.alcohol_max,
								xxx.composition,
								xxx.composition_web_paths,
								ac.name
								appellation_classification_name,
								ac.acronym
								appellation_classification_acronym,
								hm.name
								harvesting_method_name,
								www.aroma_names aroma_names,
								zzz.entity_id,
								zzz.short_url,
								zzz.AUTHOR_RIGHT_URL,
								zzz.AUTHOR_FIRST_NAME,
								zzz.AUTHOR_LAST_NAME,
								zzz.AUTHOR_ALIAS,
								zzz.AUTHOR_DATE,
								zzz.DOMINANT_COLOR_RGB,
								zzz.ORIGIN_SITE_URL,
								zzz.PICTURE_SYMLINK_CORE,
								zzz.PICTURE_MEDIUM_SYMLINK,
								zzz.PICTURE_SMALL_SYMLINK,

								yyy.id i18n_description_id,
								yyy.entity_id i18n_description_entity_id,
								yyy.AUTHOR_RIGHT_URL
								I18N_DESCRIPTION_AUTHOR_RIGHT_URL,
								yyy.AUTHOR_FIRST_NAME
								I18N_DESCRIPTION_AUTHOR_FIRST_NAME,
								yyy.AUTHOR_LAST_NAME
								I18N_DESCRIPTION_AUTHOR_LAST_NAME,
								yyy.AUTHOR_ALIAS
								I18N_DESCRIPTION_AUTHOR_ALIAS,
								yyy.DESCRIPTION I18N_DESCRIPTION,
								yyy.i18n_language_code i18n_language_code,

								co.name color_name,
								co.rgb color_rgb,
								bbb.lieu_dit_names,
								bbb.lieu_dit_web_paths,
								bt.name bottle_type_name,
								bt.icon bottle_type_icon
								from
								ref_appelation a
								left outer join
								(
								select axld.ref_appelation_id,
								GROUP_CONCAT(DISTINCT ld.name order by ld.name) lieu_dit_names,
								GROUP_CONCAT(DISTINCT ld.web_path order by ld.web_path)
								lieu_dit_web_paths
								from ref_appelation_x_lieu_dit axld, lieu_dit
								ld where
								axld.lieu_dit_id = ld.id
								group by axld.ref_appelation_id
								) bbb on a.id = bbb.ref_appelation_id
								left outer join
								(
								select
								ac.ref_appelation_id,
								GROUP_CONCAT(DISTINCT c.name order by
								c.name) cepage_names,
								GROUP_CONCAT(DISTINCT c.web_path order by
								c.web_path) cepage_web_paths,
								GROUP_CONCAT(DISTINCT
								CONCAT_WS('|',c.name, c.web_path,
								ac.percent, ac.percent_qualifier) order by c.name) composition,
								GROUP_CONCAT(DISTINCT CONCAT_WS('|',c.web_path, ac.percent,
								ac.percent_qualifier) order by c.name) composition_web_paths
								from ref_appelation_composition ac left outer join cepage c on
								ac.cepage_id = c.id
								group by ac.ref_appelation_id
								) xxx on a.id =
								xxx.ref_appelation_id
								left outer join (
								select
								pev.entity_id,
								pev.short_url,
								pev.AUTHOR_RIGHT_URL,
								pev.AUTHOR_FIRST_NAME,
								pev.AUTHOR_LAST_NAME,
								pev.AUTHOR_ALIAS,
								pev.AUTHOR_DATE,
								pev.DOMINANT_COLOR_RGB,
								pev.ORIGIN_SITE_URL,
								concat_ws('_',
								pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
								concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id),
								pev.extension) PICTURE_MEDIUM_SYMLINK,
								concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id),
								pev.extension) PICTURE_SMALL_SYMLINK
								from picture_entity_value
								pev where pev.entity='ref_appelation' and
								pev.display_order = 1
								AND (sub_type is null or sub_type = 'image')
								) zzz on a.id =
								zzz.entity_id

								left outer join
								(
								select
								eee.id,
								eee.entity_id,
								eee.AUTHOR_RIGHT_URL,
								eee.AUTHOR_FIRST_NAME,
								eee.AUTHOR_LAST_NAME,
								eee.AUTHOR_ALIAS,
								eee.description,
								eee.i18n_language_code,
								eee.score
								from
								(
								select bbb.entity_id,
								max(bbb.score) max_score
								from(
								select
								dev.entity_id,
								case when
								i18n_language_code = ? then 2 when i18n_language_code =
								'EN' then
								1 else 0 end score
								from description_entity_value dev where
								dev.entity='ref_appelation'
								) bbb
								) ddd ,
								(
								select
								dev.id,
								dev.entity_id,
								dev.AUTHOR_RIGHT_URL,
								dev.AUTHOR_FIRST_NAME,
								dev.AUTHOR_LAST_NAME,
								dev.AUTHOR_ALIAS,
								dev.i18n_language_code,
								dev.description,
								case when i18n_language_code = ? then 2 when
								i18n_language_code =
								'EN' then 1 else 0 end score
								from
								description_entity_value dev where dev.entity='ref_appelation'
								)
								eee
								where ddd.entity_id = eee.entity_id
								and ddd.max_score =
								eee.score
								) yyy on a.id = yyy.entity_id


								left outer join (
								select
								axa.ref_appelation_id,
								GROUP_CONCAT(DISTINCT a.name order by axa.SEQUENCE_ORDER) aroma_names
								from ref_appellation_x_aroma axa, ref_aroma a
								where axa.ref_aroma_id = a.id
								group by axa.ref_appelation_id
								) www on a.id = www.ref_appelation_id

								left outer join REF_HARVESTING_METHOD hm on
								a.REF_HARVESTING_METHOD_ID = hm.id
								left outer join
								REF_BOTTLE_TYPE bt on a.BOTTLE_TYPE_ID = bt.ID
								left outer join
								ref_appelation_classification ac on
								a.ref_appelation_classification_id = ac.id
								left outer join color
								co on a.color_id = co.id
								, region r
								, country coun
								where
								a.region_id = r.id
								and r.country_id = coun.id

								$wherewebpath
								$whereregionwebpath
								$wherecountrywebpath
								$wherecepagewebpath
								$wherelieuditwebpath
								$wherecolor
								order by coun.display_order,
								r.name, ac.name
							</value><!-- TODO $wherecepagewebpath to view in with all the appellation 
								using this cepage -->
						</query-body>
						<query-params>
							<query-param name="language" is-mandatory="true"
										 type="string" sample="'FR'" default="EN"></query-param>
							<query-param name="language2" refname="language"></query-param>
						</query-params>
						<query-filters>
							<query-filter name="wherewebpath"
										  and-where-connection="and">
								<value><![CDATA[ a.web_path = ? ]]></value>
								<query-params>
									<query-param name="webpath" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereregionwebpath"
										  and-where-connection="and">
								<value><![CDATA[ r.web_path = ? ]]></value><!-- 
									in (?...) does not work maybe integer is-in-clause="true" -->
								<query-params>
									<query-param name="region_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value><![CDATA[ coun.web_path = ? ]]></value><!-- 
									in (?...) does not work maybe integer is-in-clause="true" -->
								<query-params>
									<query-param name="country_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecepagewebpath"
										  and-where-connection="and">
								<value><![CDATA[ xxx.composition_web_paths like ? ]]></value><!-- 
									in (?...) does not work maybe integer is-in-clause="true" -->
								<query-params>
									<query-param name="cepage_web_path" type="string"
												 sample="'XXX'">
										<property name="like-mode" value="contains"></property>
										<!-- TODO error multiple ex : webpath cabernet and cabernet-franc, 
											if search for cabernet => finds also cabernet-franc -->
									</query-param>
								</query-params>
							</query-filter>
							<!-- -->
							<query-filter name="wherelieuditwebpath"
										  and-where-connection="and">
								<value><![CDATA[ bbb.lieu_dit_web_paths like ? ]]></value>
								<query-params>
									<query-param name="lieu_dit_web_path" type="string"
												 sample="'XXX'">
										<property name="like-mode" value="contains"></property>

									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecolor"
										  and-where-connection="and">
								<value><![CDATA[ lower(co.name) = lower(?) ]]></value>
								<query-params>
									<query-param name="color" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- public for winery abstract -->
					<!-- TODO extends for lieu_dit filter (left join outer lieu_dit) -->
					<query name="winery_public" id="winery_public" package-name="winery">
						<query-body>
							<value>
SELECT
*
FROM
(
SELECT
w.id id,
w.id domain_id,
w.name domain,
w.web_path,
w.display_order,
w.HAS_AGREED_PURCHASE_ORDER_OPTION,
w.description description,
w.longitude longitude,
w.latitude
latitude,
w.tags tags,
w.website_url website_url,
w.since since,
w.nb_of_hectars,
w.purchase_url,
w.PURCHASE_ORDER_EMAIL,
w.PURCHASE_ORDER_ENABLED,
w.PURCHASE_ORDER_LANGUAGE_CODE,
w.purchase_order_payment_in_advance,
w.HECTOLITERS_PER_HECTAR,
w.ALTITUDE_MIN,
w.ALTITUDE_MAX,
w.IS_BIO,
w.IS_BIO_DYNAMIC,
w.IS_BIO_SINCE_YEAR,
w.CERTIFIED_BIO_YEAR,
w.CERTIFIED_BIO_DYNAMIC_YEAR,
w.HARVESTING_METHOD_ID,
w.ORIENTATION,
w.PLANTATION_DENSITY_PER_HECTAR,
ssi.social_network_details,
case
when logo_id is not null then true else false end has_logo,
case
when price_list_id is not null then true else false end
has_price_list,
case when technical_sheet_id is not null then
true else false end has_technical_sheet,
mmm.label_details,
GROUP_CONCAT(DISTINCT p.id
ORDER BY
p.id) picture_ids,
GROUP_CONCAT(
DISTINCT p.short_url
ORDER BY
p.short_url
)
picture_short_urls,
ld.name lieu_dit,
ld.web_path
lieu_dit_web_path,
ld.id lieu_dit_id,
r.name region,
r.web_path
region_web_path,
r.id region_id,
c.name country,
c.web_path
country_web_path,
c.flag_icon country_flag_icon,
c.id country_id,
w.bill_contact_id bill_contact_id,
co.name contact,
co.street1
contact_street1,
co.street2 contact_street2,
co.post_code
contact_post_code,
co.city contact_city,
co.mail contact_mail,
co.telephone contact_phone,
GROUP_CONCAT(ce.name) cepage_names,
GROUP_CONCAT(ce.web_path) cepage_web_paths,
GROUP_CONCAT(wxc.cepage_id) cepage_ids,
CASE WHEN COUNT(gh.ID) > 0 THEN TRUE ELSE FALSE
END has_guest_house,
CASE WHEN COUNT(vt.ID) > 0 THEN TRUE ELSE FALSE
END has_visit_timetable,
w.creation_date,
w.last_modification,
r.name region_name,
c.name country_name,
xxx.appellation_names,
xxx.appellation_web_paths,
xxx.appellation_details,
xxx.nb_of_products,
xxx.products_details,
yyy.id i18n_description_id,
yyy.entity_id
i18n_description_entity_id,
yyy.AUTHOR_RIGHT_URL
I18N_DESCRIPTION_AUTHOR_RIGHT_URL,
yyy.AUTHOR_FIRST_NAME
I18N_DESCRIPTION_AUTHOR_FIRST_NAME,
yyy.AUTHOR_LAST_NAME
I18N_DESCRIPTION_AUTHOR_LAST_NAME,
yyy.AUTHOR_ALIAS
I18N_DESCRIPTION_AUTHOR_ALIAS,
yyy.DESCRIPTION I18N_DESCRIPTION,
yyy.i18n_language_code i18n_language_code,
zzz.PICTURE_ID,
zzz.short_url,
zzz.AUTHOR_RIGHT_URL,
zzz.AUTHOR_FIRST_NAME,
zzz.AUTHOR_LAST_NAME,
zzz.AUTHOR_ALIAS,
zzz.AUTHOR_DATE,
zzz.PICTURE_SYMLINK_CORE,
zzz.PICTURE_MEDIUM_SYMLINK,
zzz.PICTURE_SMALL_SYMLINK,
ewp.event_winery_participation
FROM
winery w
LEFT OUTER JOIN
(
SELECT
lxw.winery_id,
GROUP_CONCAT(
CONCAT_WS(
'|',
l.id,
l.name,
l.web_path,
l.code
)
ORDER BY
lxw.display_order
) label_details
FROM
REF_LABEL_X_WINERY lxw,
ref_label l
WHERE
lxw.label_id = l.id
GROUP by lxw.winery_id
) mmm on mmm.winery_id = w.id
LEFT OUTER JOIN
(
SELECT
uuu.winery_id,
GROUP_CONCAT(
uuu.appellation_web_paths
ORDER BY
uuu.appellation_web_paths
)  appellation_web_paths,
GROUP_CONCAT(
uuu.appellation_names
ORDER BY
uuu.appellation_names
)  appellation_names,
uuu.nb_of_products,
GROUP_CONCAT(
uuu.appellation_details
ORDER BY
uuu.appellation_names
) appellation_details,
GROUP_CONCAT(
CONCAT_WS(
'|',
uuu.products_details,
uuu.nb_of_products
)
ORDER BY
uuu.appellation_names
) products_details
FROM
(
SELECT
p.winery_id,
a.id appellation_id,
GROUP_CONCAT(
DISTINCT a.web_path
ORDER BY
a.web_path
) appellation_web_paths,
GROUP_CONCAT(
DISTINCT a.name
ORDER BY
a.name
) appellation_names,
GROUP_CONCAT(
DISTINCT CONCAT_WS('|',
a.name,
ac.acronym,
ac.name)
ORDER BY
a.name
) appellation_details,
GROUP_CONCAT(
DISTINCT CONCAT_WS(
'|',
IFNULL(a.name,
' '),
IFNULL(ac.acronym,
' '),
IFNULL(ac.name,
' '),
IFNULL(a.web_path,
' '),
c.rgb,
c.name
)
ORDER BY
a.name
) products_details,
COUNT(p.id) nb_of_products
FROM
product p
LEFT OUTER JOIN
ref_appelation a ON p.appelation_id = a.id
LEFT OUTER JOIN
ref_appelation_classification ac ON a.ref_appelation_classification_id = ac.id
LEFT OUTER JOIN
color c ON p.color_id = c.id
where p.active = 1 and ac.acronym is not null
GROUP BY
p.winery_id,
a.id,
c.id
) uuu
GROUP BY
uuu.winery_id
) xxx ON w.id = xxx.winery_id
LEFT OUTER JOIN
(
SELECT
pev.id PICTURE_ID,
pev.entity_id,
pev.short_url,
pev.AUTHOR_RIGHT_URL,
pev.AUTHOR_FIRST_NAME,
pev.AUTHOR_LAST_NAME,
pev.AUTHOR_ALIAS,
pev.AUTHOR_DATE,
CONCAT_WS('_',
pev.short_url,
entity_id) PICTURE_SYMLINK_CORE,
CONCAT_WS(
'.MED.',
CONCAT_WS('_',
pev.short_url,
entity_id),
pev.extension
) PICTURE_MEDIUM_SYMLINK,
CONCAT_WS(
'.SML.',
CONCAT_WS('_',
pev.short_url,
entity_id),
pev.extension
) PICTURE_SMALL_SYMLINK
FROM
picture_entity_value pev
WHERE
pev.entity = 'winery' AND pev.display_order = 1 AND (sub_type is null or
sub_type = 'image')
) zzz ON w.id = zzz.entity_id
LEFT OUTER JOIN (
SELECT min(entity_id) logo_id
FROM
picture_entity_value
where
entity = 'winery' AND sub_type = 'logo'
group by entity_id
) logo on w.id = logo.logo_id
LEFT OUTER JOIN (
SELECT min(entity_id) price_list_id
FROM
picture_entity_value
where
entity = 'winery' AND sub_type = 'price_list'
group by entity_id
) price_list on w.id = price_list.price_list_id
LEFT OUTER JOIN (
SELECT min(entity_id) technical_sheet_id
FROM
picture_entity_value
where
entity = 'winery' AND sub_type = 'technical_sheet'
group by entity_id
) technical_sheet on w.id = technical_sheet.technical_sheet_id
LEFT OUTER JOIN
(
SELECT
eee.id,
eee.entity_id,
eee.AUTHOR_RIGHT_URL,
eee.AUTHOR_FIRST_NAME,
eee.AUTHOR_LAST_NAME,
eee.AUTHOR_ALIAS,
eee.description,
eee.i18n_language_code,
eee.score
FROM
(
SELECT
bbb.entity_id,
MAX(bbb.score) max_score
FROM
(
SELECT
dev.entity_id,
CASE WHEN i18n_language_code = ? THEN 2 WHEN i18n_language_code =
'EN' THEN 1 ELSE 0
END score
FROM
description_entity_value dev
WHERE
dev.entity = 'winery'
) bbb
) ddd,
(
SELECT
dev.id,
dev.entity_id,
dev.AUTHOR_RIGHT_URL,
dev.AUTHOR_FIRST_NAME,
dev.AUTHOR_LAST_NAME,
dev.AUTHOR_ALIAS,
dev.i18n_language_code,
dev.description,
CASE WHEN
i18n_language_code = ? THEN 2 WHEN i18n_language_code =
'EN' THEN
1 ELSE 0
END score
FROM
description_entity_value dev
WHERE
dev.entity = 'winery'
) eee
WHERE
ddd.entity_id = eee.entity_id AND
ddd.max_score = eee.score
) yyy ON w.id = yyy.entity_id
LEFT OUTER
JOIN
lieu_dit ld ON w.lieu_dit_id = ld.id
LEFT OUTER JOIN
winery_x_cepage wxc ON w.id = wxc.winery_id

LEFT OUTER JOIN
(select
winery_id,
GROUP_CONCAT(
DISTINCT CONCAT_WS(
'|',
link,
social_network_name
)
ORDER BY
social_network_name
) social_network_details

from
social_network_item sni
group by winery_id

)
ssi ON w.id = ssi.winery_id
LEFT OUTER JOIN (
select
winery_id,
GROUP_CONCAT(
DISTINCT CONCAT_WS(
'|',
e.web_path,
PARTICIPATION_LEVEL,
BOOTH
)
ORDER BY PARTICIPATION_LEVEL, BOOTH
)
event_winery_participation
from
EVENT_WINERY_PARTICIPATION ewp, event e
where ewp.event_id = e.id and e.active = 1
group by winery_id
)
ewp ON ewp.winery_id = w.id

LEFT OUTER JOIN
cepage ce ON wxc.cepage_id = ce.id
LEFT OUTER JOIN
winery_x_picture wxp ON w.id = wxp.winery_id
LEFT OUTER JOIN
picture p ON wxp.picture_id = p.id
LEFT OUTER JOIN
GUEST_HOUSE gh ON gh.winery_id = w.id
LEFT OUTER JOIN
VISIT_TIMETABLE vt ON vt.winery_id = w.id,

region r,
country c,
contact co
WHERE
w.active = 1 and
w.region_id = r.id AND r.country_id = c.id AND w.contact_id = co.id
GROUP BY
w.id
) xxx
$wherewineryid
$wherewebpath
$wherecountrywebpath
$whereregionwebpath
$wherecepagewebpath
$wherelieuditwebpath
$whereappellationwebpath
$whereeventwebpath2
order by display_order desc, HAS_AGREED_PURCHASE_ORDER_OPTION desc, last_modification desc

							</value>
						</query-body>
						<query-params>
							<query-param name="language" is-mandatory="true"
										 type="string" sample="'FR'" default="EN"></query-param>
							<query-param name="language2" refname="language"></query-param>
						</query-params>
						<query-filters>
							<query-filter name="wherewineryid"
										  and-where-connection="where">
								<value><![CDATA[ xxx.domain_id = ? ]]></value><!-- 
									in (?...) does not work maybe integer is-in-clause="true" -->
								<query-params>
									<query-param name="winery_id" type="integer" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewebpath"
										  and-where-connection="where">
								<value><![CDATA[ xxx.web_path = ? ]]></value>
								<query-params>
									<query-param name="web_path" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="where">
								<value><![CDATA[ xxx.country_web_path = ? ]]></value>
								<query-params>
									<query-param name="country_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereregionwebpath"
										  and-where-connection="where">
								<value><![CDATA[ xxx.region_web_path = ? ]]></value>
								<query-params>
									<query-param name="region_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecepagewebpath"
										  and-where-connection="where">
								<value><![CDATA[ xxx.cepage_web_paths like ? ]]></value>
								<query-params>
									<query-param name="cepage_web_path" type="string"
												 sample="'XXX'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherelieuditwebpath"
										  and-where-connection="where">
								<value><![CDATA[ xxx.lieu_dit_web_path = ? ]]></value>
								<query-params>
									<query-param name="lieu_dit_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereappellationwebpath"
										  and-where-connection="where">
								<value>
									<![CDATA[ xxx.appellation_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="appellation_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
							<!-- 
							TODO add refname inside filter and not only in pure query param
															from
									EVENT_WINERY_PARTICIPATION ewp, event e
								where ewp.event_id = e.id and e.active = 1
								$whereeventwebpath1
								group by winery_id
								)
								
							<query-filter name="whereeventwebpath1"
								and-where-connection="where">
								<value>
        							<![CDATA[ e.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="event_web_path" type="string"
										sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
							 -->
							<query-filter name="whereeventwebpath2"
										  and-where-connection="where">
								<value>
									<![CDATA[ xxx.event_winery_participation like ? ]]>
								</value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
									<!--  
									<query-param name="event_web_path2" refname="event_web_path" />
									-->
								</query-params>
							</query-filter>
						</query-filters>
						<query-pagination max-result-param="limit" offset-param="offset"/>
					</query>

					<query name="wineries_public" id="wineries_public"
						   package-name="winery">
						<query-body>
							<value>
								select * from v_winery_public $wherewineriesid
								$wherewebpaths
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherewineriesid"
										  and-where-connection="where">
								<value><![CDATA[ domain_id in (?...) ]]></value>
								<query-params>
									<query-param name="wineriesId" type="int" sample="1,2"
												 is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewebpaths"
										  and-where-connection="where">
								<value><![CDATA[ web_path in (?...) ]]></value>
								<query-params>
									<query-param name="webpaths" type="string" sample="'XXX','YY'"
												 is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- -->
					<query name="get_content" id="get_content" package-name="content">
						<query-body>
							<value>
								select * from UTIL_ARTICLE $wherecategory
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecategory"
										  and-where-connection="where">
								<value><![CDATA[ category = ? ]]></value>
								<query-params>
									<query-param name="category" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- TODO create productItemList -->
					<query name="product_item_List" id="product_item_List"
						   package-name="product">
						<query-body>
							<value>

								select
								p.name product,
								p.detail detail,
								p.id product_id,
								wvu.name wine_volume_unit_name,
								wvu.icon_class wine_volume_unit_icon_class,
								wvu.volume_in_ml,
								pip.id product_item_price_id,
								pip.DISPLAY_ORDER PRODUCT_DISPLAY_ORDER,
								pip.price,
								pip.quantity,
								pip.valid_from price_valid_from,
								pip.valid_until price_valid_until,
								pip.creation_date,
								pip.last_modification,
								cu.name currency_name,
								cu.class_name currency_class_name,
								w.name winery,
								r.name region,
								w.web_path winery_web_path,
								p.web_path product_web_path,

								case when product_logo_id is not null then true else false end
								has_product_logo,
								case when winery_logo_id is not null then true else false end
								has_winery_logo,
								w.id winery_id,
								ewpip.events_details,
								pc.name product_color_name,
								pc.rgb product_color_rgb
								from
								product p
								LEFT OUTER JOIN (
								SELECT min(entity_id) product_logo_id
								FROM
								picture_entity_value
								where
								entity = 'product' AND sub_type = 'logo'
								group by entity_id
								) pl on p.id = pl.product_logo_id
								, winery w
								LEFT OUTER JOIN (
								SELECT min(entity_id) winery_logo_id
								FROM
								picture_entity_value
								where
								entity = 'winery' AND sub_type = 'logo'
								group by entity_id
								) wl on w.id = wl.winery_logo_id,
								region r,
								product_item_price pip
								LEFT OUTER JOIN (
								select
								product_item_price_id,
								GROUP_CONCAT(DISTINCT
								CONCAT_WS('|',EVENT_ID,EVENT_WEB_PATH,event_price,event_pre_order_price)
								order by EVENT_WEB_PATH) events_details
								from v_event_wine_price_item_participation
								$whereeventwebpath
								group by product_item_price_id
								) ewpip on ewpip.product_item_price_id = pip.id,
								country c,
								ref_currency cu,
								color pc,
								REF_WINE_VOLUME_UNIT wvu
								where
								p.active = 1 and w.active = 1 and pip.active = 1 and
								p.winery_id = w.id and
								w.region_id = r.id and
								pip.product_id = p.id and
								pip.wine_volume_unit_id = wvu.id and
								p.color_id = pc.id and
								r.country_id = c.id and
								c.currency_id = cu.id

								$wheredomainid
								$wherewinerywebpath
								$whereproductid
								$whereproductwebpath
								$whereproductitempriceid
								order by
								winery desc, pip.DISPLAY_ORDER asc, product desc, wvu.volume_in_ml, pip.quantity, region desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereeventwebpath"
										  and-where-connection="where">
								<value><![CDATA[ EVENT_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="event_web_path" type="string"
												 sample="'-1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wheredomainid"
										  and-where-connection="and">
								<value>
									<![CDATA[ w.id = ? ]]>
								</value>
								<query-params>
									<query-param name="wineryId" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewinerywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ w.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="winery_web_path" type="string"
												 sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductid"
										  and-where-connection="and">
								<value>
									<![CDATA[ p.id = ? ]]>
								</value>
								<query-params>
									<query-param name="productId" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ p.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="product_web_path" type="string"
												 sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductitempriceid"
										  and-where-connection="and">
								<value>
									<![CDATA[ pip.id = ? ]]>
								</value>
								<query-params>
									<query-param name="product_item_price_id" type="int"
												 sample="1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="productAndItemList" id="product_list"
						   package-name="product">
						<!-- to add hasProductLogo hasWineryLogo wineryId productColorName 
							productColorRgb productRobeName productRobeRgb -->
						<query-body>
							<value>
								select
								p.name product,
								p.detail detail,
								pip.id product_item_price_id,
								pip.price price,
								pip.year year,
								pip.valid_until price_valid_until,
								cu.name
								currency_name,
								cu.class_name currency_class_name,
								w.name winery,
								r.name region,
								w.web_path winery_web_path,
								p.id product_id,
								p.web_path product_web_path,

								case when product_logo_id is not null then true else false end
								has_product_logo,
								case when winery_logo_id is not null then true
								else false end has_winery_logo,
								w.id winery_id,
								pc.name
								product_color_name,
								pc.rgb product_color_rgb

								from product p
								LEFT OUTER JOIN (
								SELECT min(entity_id) product_logo_id
								FROM
								picture_entity_value
								where
								entity = 'product' AND sub_type = 'logo'
								group by entity_id
								) pl on p.id = pl.product_logo_id
								, winery w
								LEFT OUTER JOIN (
								SELECT min(entity_id) winery_logo_id
								FROM
								picture_entity_value
								where
								entity = 'winery' AND sub_type = 'logo'
								group by entity_id
								) wl on w.id = wl.winery_logo_id

								, region r, product_item_price pip, country c, color pc,
								ref_currency cu
								where
								p.active = 1 and w.active = 1 and
								p.winery_id = w.id and
								w.region_id = r.id and
								pip.product_id = p.id and
								pip.active = 1 and
								p.color_id = pc.id and
								r.country_id = c.id and
								c.currency_id = cu.id
								$wheredomainid
								$wherewinerywebpath
								$whereproductid
								$whereproductwebpath
								$whereproductitempriceid
								order by region desc, winery desc, product desc, year desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wheredomainid"
										  and-where-connection="and">
								<value>
									<![CDATA[ w.id = ? ]]>
								</value>
								<query-params>
									<query-param name="wineryId" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewinerywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ w.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="winery_web_path" type="string"
												 sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductid"
										  and-where-connection="and">
								<value>
									<![CDATA[ p.id = ? ]]>
								</value>
								<query-params>
									<query-param name="productId" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ p.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="product_web_path" type="string"
												 sample="'1'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereproductitempriceid"
										  and-where-connection="and">
								<value>
									<![CDATA[ pip.id = ? ]]>
								</value>
								<query-params>
									<query-param name="product_item_price_id" type="int"
												 sample="1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- remove by v_product_abstract -->
					<query name="productList" id="product_list" package-name="product">
						<query-body>
							<value>
								select p.name product, p.detail detail, p.is_bio is_bio,
								p.is_aoc is_aoc
								from product p
								where p.active = 1
								$wheredomainid
								order by p.name desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wheredomainid"
										  and-where-connection="and">
								<value>
									<![CDATA[ p.winery_id = ? ]]>
								</value>
								<query-params>
									<query-param name="wineryId" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- picture -->
					<query name="image_info" id="image_info" package-name="image">
						<query-body>
							<value>
								<![CDATA[
select 
pev.NAME,
pev.ENTITY,
pev.ENTITY_ID,
pev.DISPLAY_ORDER,
pev.TYPE,
pev.SHORT_URL,
pev.PATH,
pev.ENTITY_WEB_PATH as WEB_PATH,
pev.DESCRIPTION,
pev.WIDTH,
pev.HEIGHT,
pev.SIZE,
pev.EXTENSION,
pev.AUTHOR_FIRST_NAME, 
pev.AUTHOR_LAST_NAME, 
pev.AUTHOR_ALIAS, 
pev.AUTHOR_RIGHT_URL, 
pev.AUTHOR_DATE,
pev.DOMINANT_COLOR_RGB,
pev.PATH_ON_STORE,
pev.CREATION_DATE,
pev.LAST_MODIFICATION,
pev.IS_WINERY_PROJECT_PROPERTY,
pev.ORIGIN_SITE_URL,
pev.TAGS,
pev.FILENAME,
pev.sub_type,
concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
 from picture_entity_value pev
$whereentity
order by pev.DISPLAY_ORDER
]]>
							</value>
						</query-body>
						<query-chunks>
							<query-chunk name="whereentity"
										 sample-value=", cepage c where pev.entity_id = c.id and entity = 'cepage' and c.name = 'Merlot'">
								<query-chunk-params>
									<query-chunk-param id="web_path" name="web_path"
													   type="string" sample="'merlot'"></query-chunk-param>
								</query-chunk-params>
								<query-chunk-value name="cepage"
												   value=", cepage c where pev.entity_id = c.id and entity = 'cepage' and c.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="lieu_id"
												   value=", lieu_dit ld where pev.entity_id = ld.id and entity = 'lieu_dit' and ld.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="region"
												   value=", region r where pev.entity_id = r.id and entity = 'region' and r.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="region_lieu_dits"
												   value=", region r, lieu_dit ld where pev.entity_id = ld.id and entity = 'lieu_dit' and ld.region_id = r.id and r.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="country"
												   value=", country c where pev.entity_id = c.id and entity = 'country' and c.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="country_regions"
												   value=", region r, country c where pev.entity_id = r.id and entity = 'region' and r.country_id = c.id and c.web_path =  ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="winery"
												   value=", winery w where w.active = 1 and pev.entity_id = w.id and entity = 'winery' and w.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="winery_products"
												   value=", product p, winery w where pev.entity_id = p.id and and entity = 'product' and p.winery_id = w.id and w.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
								<query-chunk-value name="product"
												   value=", product p where p.active=1 and pev.entity_id = p.id and entity = 'product' and p.web_path = ? and extension = 'jpg' and sub_type = 'default'"
												   params="web_path" />
							</query-chunk>
						</query-chunks>
					</query>
					<query name="image_author" id="image_author" package-name="image">
						<query-body>
							<value>
								<![CDATA[
select AUTHOR_FIRST_NAME, AUTHOR_LAST_NAME, AUTHOR_ALIAS, AUTHOR_RIGHT_URL, AUTHOR_DATE, DOMINANT_COLOR_RGB
from PICTURE_ENTITY_VALUE
$whereid
$whereentityid
$whereentitywebpath
$wheredisplayorder
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereid" and-where-connection="where">
								<value>
									<![CDATA[ ID = ? ]]>
								</value>
								<query-params>
									<query-param name="id" type="int" sample="1" />
								</query-params>
							</query-filter>
							<query-filter name="whereentitywebpath"
										  and-where-connection="where">
								<value>
									<![CDATA[ entity_web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="entity_web_path" type="string"
												 sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="whereentityid"
										  and-where-connection="where">
								<value>
									<![CDATA[ entity_id = ? ]]>
								</value>
								<query-params>
									<query-param name="entity_id" type="int" sample="1" />
								</query-params>
							</query-filter>
							<query-filter name="wheredisplayorder"
										  and-where-connection="where">
								<value>
									<![CDATA[ display_order = ? ]]>
								</value>
								<query-params>
									<query-param name="display_order" type="int"
												 sample="1" />
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- cepage -->
					<query name="cepage_tokenfield" id="cepage_tokenfield"
						   package-name="cepage">
						<query-body>
							<value>
								<![CDATA[select name as value, name as label from cepage order by name desc]]>
							</value>
						</query-body>
					</query>
					<query name="cepage_description" id="cepage_description"
						   package-name="cepage">
						<query-body>
							<value>
								<![CDATA[
select c.id, c.name, c.web_path, c.description, c.url_description, c.aliases, c.color_id, 
co.name color_name, co.base_color, co.is_robe_color, co.rgb rbg, co.i18n_code,
pco.name parent_color_name, co.rgb parent_rbg, co.i18n_code parent_i18n_code,
xxx.country_names,
xxx.country_web_paths,
zzz.entity_id,
zzz.short_url,
zzz.AUTHOR_RIGHT_URL,
zzz.AUTHOR_FIRST_NAME,
zzz.AUTHOR_LAST_NAME,
zzz.AUTHOR_ALIAS,
zzz.AUTHOR_DATE,
zzz.DOMINANT_COLOR_RGB,
zzz.PICTURE_SYMLINK_CORE,
zzz.PICTURE_MEDIUM_SYMLINK,
zzz.PICTURE_SMALL_SYMLINK
from cepage c 
left outer join (
select 
pev.entity_id,
pev.short_url,
pev.AUTHOR_RIGHT_URL,
pev.AUTHOR_FIRST_NAME,
pev.AUTHOR_LAST_NAME,
pev.AUTHOR_ALIAS,
pev.AUTHOR_DATE,
pev.DOMINANT_COLOR_RGB,
concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
from picture_entity_value pev where pev.entity='cepage' and pev.display_order = 1 AND (sub_type is null or sub_type = 'image')
) zzz on c.id = zzz.entity_id 

left outer join 
(
select cxr.cepage_id,
GROUP_CONCAT(DISTINCT c.name order by c.name) country_names,
GROUP_CONCAT(DISTINCT c.web_path order by c.web_path) country_web_paths
from country c, region r, cepage_x_region cxr where r.country_id = c.id and cxr.region_id = r.id
group by cxr.cepage_id
) xxx on c.id = xxx.cepage_id

, color co left outer join color pco on co.parent_color_id = pco.id
where c.color_id = co.id
$wherecepagename
$wherewebpath
$wherecolor
$wherecountrywebpath
order by c.name
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecepagename"
										  and-where-connection="and">
								<value>
									<![CDATA[ lower(c.name) = lower(?) ]]>
								</value>
								<query-params>
									<query-param name="name" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="wherewebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ c.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="web_path" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="wherecolor"
										  and-where-connection="and">
								<value><![CDATA[ lower(co.name) = lower(?) ]]></value>
								<query-params>
									<query-param name="color" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ xxx.country_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="country_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- cepage filter queries -->
					<!-- select2 DDL winery creation -->
					<query name="proposed_cepage_for_region" id="proposed_cepage_for_region"
						   package-name="cepage">
						<query-body>
							<value>
								<![CDATA[
select www.id id, www.name name,
(case when sum(www.score_region)>0 then www.region when sum(www.score_country)>0 then www.country else 'Other' end) origin,
sum(www.score_region) score_region, sum(www.score_country) score_country
 from
(
select c.id, c.name,
 (case when ? = r.id then 1 else 0 end) score_region, r.name region,
(case when yyy.country_id = co.id then 1 else 0 end) score_country, co.name country
from cepage c, region r, cepage_x_region cxr, country co
,
(
 select co.id country_id from region r, country co where r.country_id = co.id and r.id = ?
) yyy
where cxr.region_id = r.id and cxr.cepage_id = c.id and r.country_id = co.id
) www
group by id
order by score_region desc, score_country desc, name
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="region_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
							<query-param name="region_id2" refname="region_id"></query-param>
						</query-params>
						<query-pivots>
							<query-pivot name="cepage" columns="id, name" pivot="id"></query-pivot>
							<query-pivot name="origin" columns="origin" pivot="origin"></query-pivot>
						</query-pivots>
					</query>

					<!-- select2 DDL winery product creation -->
					<query name="cepage_for_product" id="cepage_for_product"
						   package-name="cepage">
						<query-body>
							<value>
								<![CDATA[
select cepage_id, c.name, sum(score_winery) score_winery, sum(score_region) score_region
from
(
select xxx.cepage_id cepage_id, 1 score_winery , 0 score_region
from
(select wxc.cepage_id, w.id winery_id from winery w
        left outer join
    winery_x_cepage wxc ON wxc.winery_id = w.id
where
    w.id = ?
) xxx
union
select yyy.cepage_id cepage_id, 0 score_winery , 1 score_region
from
(select cxr.cepage_id, w.id winery_id from
	winery w,
    region r left outer join
    cepage_x_region cxr ON cxr.region_id = r.id
where
	w.region_id= r.id
	and w.id = ?
) yyy
) zzz, cepage c
where zzz.cepage_id = c.id
group by cepage_id
order by score_winery desc, score_region desc
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="winery_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
							<query-param name="winery_id2" refname="winery_id"></query-param>
						</query-params>
					</query>

					<!-- select2 DDL winery product creation -->
					<query name="cepage_inside_circle" id="cepage_inside_circle"
						   package-name="cepage">
						<query-body>
							<value>
								<![CDATA[
SELECT distinct xxx.id
 , xxx.name
 , sum(xxx.cnt) score

from
(
  select c.id, c.name, 1 cnt
	from
	cepage c, product_x_cepage pxc, product p, winery w
    where p.active = 1 and w.active = 1 and pxc.cepage_id = c.id and pxc.product_id = p.id
	and p.winery_id = w.id
	and
	($distanceunit * acos(cos(radians(?)) * cos(radians(latitude)) * cos(radians(longitude) - radians(?))
	+ sin(radians(?)) * sin(radians(latitude)))) < ?
) xxx
group by xxx.name
order by score desc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param id="latitudeId" name="latitude"
										 is-mandatory="true" type="double" sample="48.5"></query-param>
							<query-param name="longitude" is-mandatory="true"
										 type="double" sample="7"></query-param>
							<query-param name="latitude2" refname="latitude"></query-param>
							<query-param name="range" is-mandatory="true" type="int"
										 sample="2"></query-param>
						</query-params>
						<query-chunks>
							<query-chunk name="distanceunit" sample-value="3959">
								<query-chunk-value name="km" value="6371" />
								<query-chunk-value name="miles" value="3959" />
							</query-chunk>
						</query-chunks>
					</query>

					<!-- end cepage -->
					<query name="country_list" id="country_list" package-name="country">
						<query-body>
							<value>
								<![CDATA[
select c.id, c.name, c.description, c.flag_icon, cont.name continent_name 
from country c, continent cont 
where c.continent_id = cont.id 
order by cont.display_order, c.display_order, c.name asc
]]>
							</value>
						</query-body>
						<!-- when pagination add wrapper mysql : limit offset, max-result max-result 
							and offset to add as param variable if offset not "set" => start with 0 as 
							query-params (mandatory) -->
						<query-pagination max-result-param="limit"
										  offset-param="offset"></query-pagination>
					</query>

					<!-- states -->
					<query name="state_list" id="state_list" package-name="country">
						<query-body>
							<value>
								select s.id id,
								s.name name,
								s.WEB_PATH web_path,
								s.CODE code
								from REF_COUNTRY_STATE s
								$wherecountryid
								order by s.name asc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecountryid"
										  and-where-connection="where">
								<value>
									<![CDATA[ s.COUNTRY_ID = ? ]]>
								</value>
								<query-params>
									<query-param name="country_id" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- end states -->
					<query name="country_description" id="country_description"
						   package-name="country">
						<query-body>
							<value>
								<![CDATA[
select c.id id, 
c.name name, 
cont.name continent_name, 
c.flag_icon, 
c.description, 
c.longitude_center, 
c.latitude_center, 
c.i18n_language_code,
c.google_zoom,
c.emoji,
c.web_path
from country c, continent cont 
where c.continent_id = cont.id
$wherecountrywebpath
order by cont.display_order, c.display_order, c.name asc
]]> <!-- TODO Add picture first -->
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ c.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="web_path" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="country_description_with_info" id="country_description_with_info"
						   package-name="country">
						<query-body>
							<value>
								<![CDATA[
select c.id id, 
c.name name, 
cont.name continent_name, 
c.flag_icon, 
c.description, 
c.longitude_center, 
c.latitude_center, 
c.i18n_language_code,
c.google_zoom,
c.emoji,
c.web_path,
zzz.nb_of_regions,
yyy.nb_of_appellations,
xxx.cepage_names,
pev.short_url,
pev.AUTHOR_RIGHT_URL,
pev.AUTHOR_FIRST_NAME,
pev.AUTHOR_LAST_NAME,
pev.AUTHOR_ALIAS,
pev.AUTHOR_DATE,
pev.DOMINANT_COLOR_RGB,
concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
from country c 
LEFT OUTER JOIN
(
    select country_id, count(*) as nb_of_regions
    from region r group by country_id
) zzz 
on zzz.country_id = c.id
LEFT OUTER JOIN
(
	select r.country_id, count(distinct a.id) as nb_of_appellations
    from region r, ref_appelation a where a.region_id = r.id
    group by r.country_id
) yyy 
on yyy.country_id = c.id
left outer join picture_entity_value pev on c.id = pev.entity_id and pev.entity='country' and pev.display_order = ?
left outer join 
(
select r.country_id, group_concat(distinct ce.name order by ce.name) cepage_names
from region r, cepage_x_region cxr, cepage ce
where
 cxr.region_id = r.id
and cxr.cepage_id = ce.id
group by r.country_id
) xxx on xxx.country_id = c.id,
continent cont
where c.continent_id = cont.id
$wherecountrywebpath
$wherecepagewebpath
order by cont.display_order, c.display_order, c.name asc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param id="wheredisplayorder" name="display_order"
										 is-mandatory="true" type="int" sample="48"></query-param>
						</query-params>
						<query-filters>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ c.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="web_path" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="wherecepagewebpath"
										  and-where-connection="and">
								<value><![CDATA[ xxx.cepage_names like ? ]]></value><!-- 
									in (?...) does not work maybe integer is-in-clause="true" -->
								<query-params>
									<query-param name="cepage_web_path" type="string"
												 sample="'XXX'">
										<property name="like-mode" value="contains"></property>
										<!-- TODO error multiple ex : webpath cabernet and cabernet-franc, 
											if search for cabernet => finds also cabernet-franc -->
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="country_list_having_region" id="country_list"
						   package-name="country">
						<query-body>
							<value>
								<![CDATA[
  select c.id, c.name, c.description
 from country c, region r
 where r.country_id = c.id
 group by c.id, c.name, c.description
 order by name asc
 ]]>
							</value>
						</query-body>
					</query>

					<query name="region_list" id="region_list" package-name="region">
						<query-body>
							<value>
								<![CDATA[select id, name, description, longitude_center, latitude_center, google_zoom from region r where r.country_id = ? order by name asc]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="country_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
					</query>
					<query name="region_badge" id="region_badge" package-name="region">
						<query-body>
							<value>
								<![CDATA[
select r.id, r.name, r.web_path, r.description, r.longitude_center, r.latitude_center, r.google_zoom, 
c.name country_name,
c.web_path country_web_path,
c.flag_icon country_flag_icon,
xxx.nb_wineries, xxx.cepage_names winery_cepage_names, xxx.cepage_web_paths winery_cepage_paths,
yyy.cepage_names, yyy.cepage_web_paths,
zzz.entity_id,
zzz.short_url,
zzz.AUTHOR_RIGHT_URL,
zzz.AUTHOR_FIRST_NAME,
zzz.AUTHOR_LAST_NAME,
zzz.AUTHOR_ALIAS,
zzz.AUTHOR_DATE,
zzz.DOMINANT_COLOR_RGB,
zzz.PICTURE_SYMLINK_CORE,
zzz.PICTURE_MEDIUM_SYMLINK,
zzz.PICTURE_SMALL_SYMLINK,
www.id i18n_description_id,
www.entity_id i18n_description_entity_id,
www.AUTHOR_RIGHT_URL I18N_DESCRIPTION_AUTHOR_RIGHT_URL,
www.AUTHOR_FIRST_NAME I18N_DESCRIPTION_AUTHOR_FIRST_NAME,
www.AUTHOR_LAST_NAME I18N_DESCRIPTION_AUTHOR_LAST_NAME,
www.AUTHOR_ALIAS I18N_DESCRIPTION_AUTHOR_ALIAS,
www.DESCRIPTION I18N_DESCRIPTION,

aaa.appellation_names, 
aaa.appellation_web_paths
from country c, 
region r left outer join
(
select cxr.region_id, 
GROUP_CONCAT(DISTINCT c.name order by c.name) cepage_names, 
GROUP_CONCAT(DISTINCT c.web_path order by c.web_path) cepage_web_paths 
from cepage_x_region cxr, cepage c
where cxr.cepage_id = c.id
group by cxr.region_id
) yyy on r.id = yyy.region_id
left outer join (
select a.region_id, 
GROUP_CONCAT(DISTINCT a.name order by a.name) appellation_names, 
GROUP_CONCAT(DISTINCT a.web_path order by a.web_path) appellation_web_paths 
from ref_appelation a
group by a.region_id
) aaa on r.id = aaa.region_id
left outer join (
select 
pev.entity_id,
pev.short_url,
pev.AUTHOR_RIGHT_URL,
pev.AUTHOR_FIRST_NAME,
pev.AUTHOR_LAST_NAME,
pev.AUTHOR_ALIAS,
pev.AUTHOR_DATE,
pev.DOMINANT_COLOR_RGB,
concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
from picture_entity_value pev where pev.entity='region' and pev.display_order = 1 AND (sub_type is null or sub_type = 'image')
) zzz on r.id = zzz.entity_id 

left outer join (
select 
dev.id,
dev.entity_id,
dev.AUTHOR_RIGHT_URL,
dev.AUTHOR_FIRST_NAME,
dev.AUTHOR_LAST_NAME,
dev.AUTHOR_ALIAS,
dev.DESCRIPTION
from description_entity_value dev where dev.entity='region' and dev.i18n_language_code = 'EN'
) www on r.id = www.entity_id 
,
(
select r.id, count(distinct w.id) nb_wineries,
GROUP_CONCAT(DISTINCT c.name order by c.name) cepage_names, 
GROUP_CONCAT(DISTINCT c.web_path order by c.web_path) cepage_web_paths 
from region r left outer join winery w on w.region_id = r.id 
left outer join winery_x_cepage wxc on wxc.winery_id = w.id
left outer join cepage c on wxc.cepage_id = c.id
group by r.id
) xxx
where r.country_id = c.id and r.id = xxx.id 
$wherewebpath
$wherecountrywebpath
$wherewinerycepagewebpath
$whereappellationwebpath
$wheregradewebpath
$wherename
order by r.name asc
]]><!-- TODO picture, cepages available, cepages used -->
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ c.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="country_web_path" type="string"
												 sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="wheregradewebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ yyy.cepage_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="grade_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewinerycepagewebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ xxx.cepage_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="winery_grade_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereappellationwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ aaa.appellation_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="appellation_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ r.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="web_path" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="wherename" and-where-connection="and">
								<value>
									<![CDATA[ r.name = ? ]]>
								</value>
								<query-params>
									<query-param name="name" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="appelation_conservation_badge" id="appelation_conservation_badge"
						   package-name="appellation">
						<query-body>
							<value>
								<![CDATA[
select 
cm.name conservation_method_name,
cm.description conservation_method_description,
cm.country_id conservation_method_country_id,
cm.duration_unit conservation_method_duration_unit,
cm.DURATION_MIN conservation_method_duration_min,
cm.DURATION_MAX conservation_method_duration_max,

uuu.conservation_method_id,
uuu.sequence_order,
uuu.conservation_processing_type_name,
uuu.conservation_processing_duration_unit,
uuu.conservation_processing_duration_min,
uuu.conservation_processing_duration_max,
uuu.conservation_processing_temperature_min,
uuu.conservation_processing_temperature_max,
uuu.vat_name,
uuu.vat_material

 from
ref_conservation_method cm left outer join
(
select 
cxcp.conservation_method_id,
cxcp.sequence_order,
cpt.name conservation_processing_type_name,
cp.duration_unit conservation_processing_duration_unit,
cp.duration_min conservation_processing_duration_min,
cp.duration_max conservation_processing_duration_max,
cp.temperature_min conservation_processing_temperature_min,
cp.temperature_max conservation_processing_temperature_max,
wvt.name vat_name,
wvt.vat_material
from ref_conserv_x_conserv_processing cxcp, 
ref_conservation_processing cp, 
ref_conservation_processing_type cpt,
ref_wine_vat_type wvt
where cxcp.conservation_processing_id = cp.id 
and cxcp.conservation_processing_type_id = cpt.id
and cp.wine_vat_type_id = wvt.id
) uuu on uuu.conservation_method_id = cm.id,
ref_appelation a
where a.conservation_method_id = cm.id
$wherename
$whereappellationwebpath
order by uuu.sequence_order asc
]]><!-- TODO picture, cepages available, cepages used -->
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherename" and-where-connection="and">
								<value>
									<![CDATA[ cm.name = ? ]]>
								</value>
								<query-params>
									<query-param name="name" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="whereappellationwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ a.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="appellation_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>

					<!-- badge queries -->
					<query name="lieu_dit_list" id="lieu_dit_list" package-name="lieu_dit">
						<query-body>
							<value>
								<![CDATA[
select id, name, web_path, longitude, latitude, google_zoom 
from lieu_dit ld where ld.region_id = ? order by name asc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="region_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
					</query>
					<query name="lieu_dit_badge" id="lieu_dit_badge"
						   package-name="badge">
						<query-body>
							<value>
								<![CDATA[
select ld.*, 
r.web_path region_web_path, 
r.name region_name, 
c.web_path country_web_path, 
c.name country_name, 
c.flag_icon country_flag_icon,
bbb.appellation_names,
bbb.appellation_web_paths,
zzz.entity_id,
zzz.short_url,
zzz.AUTHOR_RIGHT_URL,
zzz.AUTHOR_FIRST_NAME,
zzz.AUTHOR_LAST_NAME,
zzz.AUTHOR_ALIAS,
zzz.AUTHOR_DATE,
zzz.DOMINANT_COLOR_RGB,
zzz.PICTURE_SYMLINK_CORE,
zzz.PICTURE_MEDIUM_SYMLINK,
zzz.PICTURE_SMALL_SYMLINK  
from 
lieu_dit ld
left outer join 
(
select axld.lieu_dit_id,
GROUP_CONCAT(DISTINCT a.name order by a.name) appellation_names,
GROUP_CONCAT(DISTINCT a.web_path order by a.web_path) appellation_web_paths
from ref_appelation_x_lieu_dit axld, ref_appelation a where axld.ref_appelation_id = a.id
group by axld.lieu_dit_id
) bbb on ld.id = bbb.lieu_dit_id
left outer join (
select 
pev.entity_id,
pev.short_url,
pev.AUTHOR_RIGHT_URL,
pev.AUTHOR_FIRST_NAME,
pev.AUTHOR_LAST_NAME,
pev.AUTHOR_ALIAS,
pev.AUTHOR_DATE,
pev.DOMINANT_COLOR_RGB,
concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
from picture_entity_value pev where pev.entity='lieu_dit' and pev.display_order = 1 AND (sub_type is null or sub_type = 'image')
) zzz on ld.id = zzz.entity_id 
, region r, country c  
where 
ld.region_id = r.id and r.country_id = c.id 
$wherewebpath $whereregionwebpath $wherecountrywebpath $whereappellationwebpath
order by r.name, ld.name desc
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherewebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ ld.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="web_path" type="string" sample="'abc'" />
								</query-params>
							</query-filter>
							<query-filter name="whereregionwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ r.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="region_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherecountrywebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ c.web_path = ? ]]>
								</value>
								<query-params>
									<query-param name="country_web_path" type="string"
												 sample="'abc'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereappellationwebpath"
										  and-where-connection="and">
								<value>
									<![CDATA[ bbb.appellation_web_paths like ? ]]>
								</value>
								<query-params>
									<query-param name="appellation_web_path" type="string"
												 sample="'abc'">
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="winery_product_badge" id="winery_product_badge"
						   package-name="badge">
						<query-body>
							<value>
								<![CDATA[
select count(*) nb_of_products, w.grades grades, w.name winery, w.description description
from product p, winery w
where p.active = 1 and w.active = 1 and p.winery_id = w.id
and w.id = ?
group by w.name, w.grades
 order by winery desc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="winery_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
					</query>


					<query name="winery_product_item_badge" id="winery_product_item_badge"
						   package-name="badge">
						<query-body>
							<value>
								<![CDATA[
select * from 
(
    select 
        p.id id,
        w.id winery_id,
        w.web_path winery_web_path,
        w.name winery_name,
        count(distinct pip.id) nb_of_items,
        p.name product,
        p.detail detail,
        p.vinification_description vinification_description,
        pic.short_url picture_short_url,
        pic.id picture_id,
        (case
            when p.is_bio is not null then p.is_bio
            else 0
        end) is_bio,
        (case
            when p.is_aoc is not null then p.is_aoc
            else 0
        end) is_aoc,
        min(pip.price) price_min,
        max(pip.price) price_max,
        case when technical_sheet_id is not null then true else false end has_technical_sheet,
        case when logo_id is not null then true else false end has_logo,
        GROUP_CONCAT(DISTINCT pip.year order by pip.year) years,
        GROUP_CONCAT(DISTINCT c.name order by c.name) cepages,
        GROUP_CONCAT(DISTINCT c.id order by c.id) cepage_ids,
        GROUP_CONCAT(DISTINCT c.id,',', c.name SEPARATOR '|') cepage_id_names,
        GROUP_CONCAT(DISTINCT c.id,',', c.name,',', pxc.PERCENT SEPARATOR '|') cepage_id_name_percents,
        GROUP_CONCAT(DISTINCT p.tags) tags
        ,GROUP_CONCAT(DISTINCT pxa.aroma_id) aroma_ids
        ,GROUP_CONCAT(DISTINCT aro.name) aroma_names
        ,co.id color_id
        ,co.rgb color_rgb
        ,co.name color_name
        ,rob.id robe_id
        ,rob.name robe_name
        ,rob.rgb robe_rgb
        ,p.taste taste
        ,ap.name appelation
        ,p.terroir_Soil_Type
        ,p.terroir_Exposition
        ,p.preserving_Temperature
        
        ,p.serving_temperature_min
        ,p.serving_temperature_max
        
        ,p.start_Consumption_Nb_Of_Year
        ,p.optimum_Consumption_Nb_Of_Year
        ,p.end_Consumption_Nb_Of_Year
        ,p.sweetness
        ,p.puissance
        ,p.bubbleness

		,p.APPELATION_ID
        ,ap.name appelation_name
		,p.wine_Chemistry_Id
		,p.sparkling_Method_Id
        ,sm.name sparkling_method_name
		,p.APPELATION_CLASSIFICATION_ID
        ,ac.name appelation_classification_name
        ,ac.acronym appelation_classification_acronym
        ,ap.web_path appelation_web_path
		,p.conservation_Method_Id
		,p.degustation_Recommandation_Id
        ,dr.name degustation_Recommandation_name
    
        ,ch.total_Sulfite_Mg_L
        ,ch.sugar_G_L
        ,ch.alcohol_Percent
        ,ch.total_Acidity_G_L
        ,ch.tannin_Mg_L
        ,hm.id harvesting_method_id
        ,hm.name harvesting_method_name

        ,bt.id bottle_type_id
        ,bt.name bottle_type_name
        
        ,p.web_path as product_web_path
        ,p.last_modification last_modification
		,p.creation_date creation_date
		
		,p.number_of_plants
		,p.hectoliters_per_hectar
		,p.nb_of_hectars
		,p.nb_of_plants_per_hectar
		
		,p.bottled_in_domain
		
		,p.altitude_min
		,p.altitude_max
		,p.conservation_duration_unit
		,p.duration_min
		,p.duration_max
		
		,p.planting_type_id
		,plt.name planting_type_name
		
		,p.pruning_type_id
		,prt.name pruning_type_name
		
		, zzz.entity_id,
		zzz.short_url,
		zzz.AUTHOR_RIGHT_URL,
		zzz.AUTHOR_FIRST_NAME,
		zzz.AUTHOR_LAST_NAME,
		zzz.AUTHOR_ALIAS,
		zzz.AUTHOR_DATE,
		zzz.DOMINANT_COLOR_RGB,
		zzz.PICTURE_SYMLINK_CORE,
		zzz.PICTURE_MEDIUM_SYMLINK,
		zzz.PICTURE_SMALL_SYMLINK,
		
		yyy.id i18n_description_id,
		yyy.entity_id i18n_description_entity_id,
		yyy.AUTHOR_RIGHT_URL I18N_DESCRIPTION_AUTHOR_RIGHT_URL,
		yyy.AUTHOR_FIRST_NAME I18N_DESCRIPTION_AUTHOR_FIRST_NAME,
		yyy.AUTHOR_LAST_NAME I18N_DESCRIPTION_AUTHOR_LAST_NAME,
		yyy.AUTHOR_ALIAS I18N_DESCRIPTION_AUTHOR_ALIAS,
		yyy.DESCRIPTION I18N_DESCRIPTION,
		yyy.i18n_language_code i18n_language_code

    from
        winery w,
        product p
            left outer join
        product_item_price pip ON pip.product_id = p.id
			        
			left outer join (
				select 
				pev.entity_id,
				pev.short_url,
				pev.AUTHOR_RIGHT_URL,
				pev.AUTHOR_FIRST_NAME,
				pev.AUTHOR_LAST_NAME,
				pev.AUTHOR_ALIAS,
				pev.AUTHOR_DATE,
				pev.DOMINANT_COLOR_RGB,
				concat_ws('_', pev.short_url, entity_id) PICTURE_SYMLINK_CORE,
				concat_ws('.MED.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_MEDIUM_SYMLINK,
				concat_ws('.SML.',concat_ws('_', pev.short_url, entity_id), pev.extension)  PICTURE_SMALL_SYMLINK
				from picture_entity_value pev where pev.entity='product' and pev.display_order = 1 AND (sub_type is null or sub_type = 'image')
				) zzz on p.id = zzz.entity_id 
			
			left outer join
				(
				select 
				eee.id,
				eee.entity_id,
				eee.AUTHOR_RIGHT_URL,
				eee.AUTHOR_FIRST_NAME,
				eee.AUTHOR_LAST_NAME,
				eee.AUTHOR_ALIAS,
				eee.description,
				eee.i18n_language_code,
				eee.score
				from
				(
				select bbb.entity_id, max(bbb.score) max_score
				from(
				select 
				dev.entity_id,
				case when i18n_language_code = ? then 2 when i18n_language_code = 'EN' then 1 else 0 end score 
				from description_entity_value dev where dev.entity='product'
				) bbb
				) ddd ,
				(
				select 
				dev.id,
				dev.entity_id,
				dev.AUTHOR_RIGHT_URL,
				dev.AUTHOR_FIRST_NAME,
				dev.AUTHOR_LAST_NAME,
				dev.AUTHOR_ALIAS,
				dev.i18n_language_code,
				dev.description,
				case when i18n_language_code = ? then 2 when i18n_language_code = 'EN' then 1 else 0 end score 
				from description_entity_value dev where dev.entity='product'
				) eee
				where ddd.entity_id = eee.entity_id
				and ddd.max_score = eee.score
			) yyy on p.id = yyy.entity_id 

			LEFT OUTER JOIN (
				SELECT min(entity_id) logo_id
				FROM
					picture_entity_value
				where
					entity = 'product' AND sub_type = 'logo'
				    group by entity_id
			) logo on p.id = logo.logo_id
			
			LEFT OUTER JOIN (
				SELECT min(entity_id) technical_sheet_id
				FROM
					picture_entity_value
				where
					entity = 'product' AND sub_type = 'technical_sheet'
				    group by entity_id
			) ts on p.id = ts.technical_sheet_id	
										
            left outer join
        ref_appelation ap ON p.appelation_id = ap.id
            left outer join
        product_x_cepage pxc on pxc.product_id = p.id
            left outer join cepage c on
        pxc.cepage_id = c.id
            left outer join wine_chemistry ch on
        p.wine_Chemistry_Id = ch.id
            left outer join ref_appelation_classification ac on
        ap.ref_appelation_classification_Id = ac.id     
            left outer join ref_degustation_Recommandation dr on
        p.degustation_Recommandation_Id = dr.id 
            left outer join ref_sparkling_method sm on
        p.sparkling_method_Id = sm.id 
            left outer join color co on
        p.color_Id = co.id 
            left outer join color rob on
        p.robe_Id = rob.id 
			left outer join ref_harvesting_method hm on
        p.harvesting_method_Id = hm.id 
			left outer join product_x_aroma pxa on
        pxa.product_id = p.id 
        	left outer join ref_aroma aro on
        pxa.aroma_id = aro.id
			left outer join picture pic on
		p.picture_id = pic.id
			left outer join ref_bottle_type bt on
		p.bottle_type_id = bt.id
			left outer join ref_planting_type plt on
		p.planting_type_id = plt.id
			left outer join ref_pruning_type prt on
		p.pruning_type_id = prt.id
		
    where
        p.winery_id = w.id and p.active = true and w.active = true
    group by p.id
) xxx
 $whereid $wherewebpath $wheredomainid $wherewinerywebpath $whereappelationwebpath 
 order by last_modification desc
							]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="language" is-mandatory="true"
										 type="string" sample="'FR'" default="EN"></query-param>
							<query-param name="language2" refname="language"></query-param>
						</query-params>
						<query-filters>
							<query-filter name="whereid" and-where-connection="where">
								<value><![CDATA[ id = ? ]]></value>
								<query-params>
									<query-param name="product_id" type="int" sample="1"><!--is-in-clause="true" -->
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewebpath"
										  and-where-connection="where">
								<value><![CDATA[ product_web_path = ? ]]></value>
								<query-params>
									<query-param name="web_path" type="string" sample="'XXX'"><!--is-in-clause="true" -->
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wheredomainid"
										  and-where-connection="where">
								<value><![CDATA[ winery_id = ? ]]></value>
								<query-params>
									<query-param name="winery_id" type="int" sample="1"><!--is-in-clause="true" -->
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherewinerywebpath"
										  and-where-connection="where">
								<value><![CDATA[ winery_web_path = ?]]></value>
								<query-params>
									<query-param name="winery_web_path" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereappelationwebpath"
										  and-where-connection="where">
								<value><![CDATA[ appelation_web_path = ?]]></value>
								<query-params>
									<query-param name="appellation_webpath" type="string"
												 sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="winery_product_conservation_badge" id="winery_product_conservation_badge"
						   package-name="badge">
						<query-body>
							<value>
								<![CDATA[
select 
uuu.*,
p.web_path product_web_path
from
(
select
cxcp.product_id,
cxcp.sequence_order,
cpt.name conservation_processing_type_name,
cp.duration_unit conservation_processing_duration_unit,
cp.duration_min conservation_processing_duration_min,
cp.duration_max conservation_processing_duration_max,
cp.temperature_min conservation_processing_temperature_min,
cp.temperature_max conservation_processing_temperature_max,
wvt.name vat_name,
wvt.vat_material
from product_x_conserv_processing cxcp, 
ref_conservation_processing cp, 
ref_conservation_processing_type cpt,
ref_wine_vat_type wvt
where cxcp.conservation_processing_id = cp.id 
and cxcp.conservation_processing_type_id = cpt.id
and cp.wine_vat_type_id = wvt.id
) uuu,
product p
where p.active = true and uuu.product_id = p.id
$whereproductwebpath 
order by uuu.sequence_order asc
							]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereproductwebpath"
										  and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="web_path" type="string" sample="'XXX'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="get_wineries_in_region" id="get_wineries_in_region"
						   package-name="region">
						<query-body>
							<value>
								<!--http://stackoverflow.com/questions/4687312/querying-within-longitude-and-latitude-in-mysql 
									https://developers.google.com/maps/articles/phpsqlsearch_v3 -->
								<![CDATA[
SELECT id, ( $distanceunit * acos( cos( radians(?) ) * cos( radians( latitude ) ) * cos( radians( longitude )
 - radians(?) ) + sin( radians(?) ) * sin( radians( latitude ) ) ) ) AS distance, latitude, longitude
 FROM winery HAVING distance < ? ORDER BY distance LIMIT 0 , ?
 ]]>
							</value>
						</query-body>
						<query-params>
							<query-param id="latitudeId" name="latitude"
										 is-mandatory="true" type="double" sample="48"></query-param>
							<query-param name="longitude" is-mandatory="true"
										 type="double" sample="7"></query-param>
							<query-param name="latitude2" refname="latitude"></query-param>
							<query-param name="range" is-mandatory="true" type="int"
										 sample="2"></query-param>
							<query-param name="nb_of_result" is-mandatory="true"
										 type="int" sample="2"></query-param>
						</query-params>
						<query-chunks>
							<query-chunk name="distanceunit" sample-value="3959">
								<query-chunk-value name="km" value="6371" />
								<query-chunk-value name="miles" value="3959" />
							</query-chunk>
						</query-chunks>
					</query>

					<query name="search" id="search" package-name="region">
						<!-- TODO add p.active = true and w.active = true -->
						<query-body>
							<value>
								<!--http://stackoverflow.com/questions/4687312/querying-within-longitude-and-latitude-in-mysql 
									https://developers.google.com/maps/articles/phpsqlsearch_v3 -->
								<![CDATA[
 SELECT
    w.id,
    w.name,
    w.since,
    coalesce(($distanceunit * acos(cos(radians(?)) * cos(radians(latitude)) * cos(radians(longitude) - radians(?)) + sin(radians(?)) * sin(radians(latitude)))), 0) AS distance,
    latitude,
    longitude,
    ppp.pay_plan_name,
    (case
        when ppp.pay_plan_name = 'free' then 1
        when ppp.pay_plan_name = 'intermediate' then 2
        when ppp.pay_plan_name = 'premium' then 3
        else 0
    end) importance,
    w.grades winery_grades,
    xxx.nb_of_items,
    xxx.nb_of_awards,
    xxx.nb_product_bio nb_product_bio,
    xxx.nb_product_aoc nb_product_aoc,
    xxx.years,
	xxx.cepages,
	xxx.cepage_ids,
    xxx.tags,
    xxx.colors,
    xxx.tastes,
    xxx.appelations
FROM
    winery w,
    user_winery_profile uwp,
    profile_pay_plan ppp,
    (select
        winery_id winery_id,
            sum(nb_of_items) nb_of_items,
            sum(nb_of_awards) nb_of_awards,
            sum(is_bio) nb_product_bio,
            sum(is_aoc) nb_product_aoc,
            GROUP_CONCAT(DISTINCT years) years,
 			GROUP_CONCAT(DISTINCT cepages) cepages,
 			GROUP_CONCAT(DISTINCT cepage_ids) cepage_ids,
            GROUP_CONCAT(DISTINCT tags) tags,
            GROUP_CONCAT(DISTINCT color_rgb) colors,
            GROUP_CONCAT(DISTINCT taste) tastes,
            GROUP_CONCAT(DISTINCT appelation) appelations
    from
        v_product_abstract
    group by winery_id) xxx
WHERE
    uwp.winery_id = w.id
        and uwp.profile_pay_plan_id = ppp.id
        and xxx.winery_id = w.id
HAVING distance < ? $apply_has_award_filter $apply_has_bio_filter $apply_has_aoc_filter $filterCepage $filterYear $filterTag $filterColor $filterAppelation
ORDER BY importance desc, distance
LIMIT 0 , 10
 ]]>
							</value>
						</query-body>

						<query-params>
							<query-param id="latitudeId" name="latitude"
										 is-mandatory="true" type="double" sample="48"></query-param>
							<query-param name="longitude" is-mandatory="true"
										 type="double" sample="7"></query-param>
							<query-param name="latitude2" refname="latitude"></query-param>
							<query-param name="range" is-mandatory="true" type="int"
										 sample="2"></query-param>
							<!-- <query-param name="nb_of_result" is-mandatory="true" type="int" 
								sample="2" index="1"></query-param> -->
						</query-params>
						<!-- $filterYear $filterTag $filterGrade $filterColor $filterAppelation -->
						<query-filters>
							<!-- <query-filter name="filterGrade" and-where-connection="and"> 
								<value><![CDATA[ xxx.grades regexp ?... ]]></value> <query-params> <query-param 
								name="grade" type="string" sample="',(grades),'" regex-start="',(" regex-end="),'" 
								regex-param-separartor="|" regex-param-wrapper="" /> </query-params> </query-filter> -->
							<!-- -->
							<query-filter name="filterCepage"
										  and-where-connection="and">
								<value><![CDATA[ find_in_set (?, cepage_ids) ]]></value>
								<query-params>
									<query-param name="cepage_id" type="int" sample="1" />
								</query-params>
							</query-filter>
							<query-filter name="filterYear"
										  and-where-connection="and">
								<value><![CDATA[ find_in_set (?, years) ]]></value>
								<query-params>
									<query-param name="year" type="string" sample="'2014'" />
								</query-params>
							</query-filter>

							<query-filter name="filterTag" and-where-connection="and">
								<value><![CDATA[ find_in_set (?, tags) ]]></value>
								<query-params>
									<query-param name="tag" type="string" sample="'tag'" />
								</query-params>
							</query-filter>

							<query-filter name="filterColor"
										  and-where-connection="and">
								<value><![CDATA[ find_in_set (?, colors) ]]></value>
								<query-params>
									<query-param name="color" type="string" sample="'green'" />
								</query-params>
							</query-filter>
							<query-filter name="filterAppelation"
										  and-where-connection="and">
								<value><![CDATA[ find_in_set (?, appelations) ]]></value>
								<query-params>
									<query-param name="appelation" type="string"
												 sample="'muscat'" />
								</query-params>
							</query-filter>
							<!-- <query-filter name="nb_of_result"> <value><![CDATA[ ? ]]></value> 
								<query-params> <query-param name="max_result" type="int" sample="10" default="10"/> 
								</query-params> </query-filter> -->
						</query-filters>
						<query-chunks>
							<query-chunk name="distanceunit" sample-value="3959">
								<query-chunk-value name="km" value="6371"
												   is-default="true" />
								<query-chunk-value name="miles" value="3959" />
							</query-chunk>
							<!-- -->
							<query-chunk name="apply_has_award_filter"
										 sample-value="AND xxx.nb_of_awards > 0">
								<query-chunk-value name="OK"
												   value="AND xxx.nb_of_awards > 0" />
								<query-chunk-value name="NO" value=""
												   is-default="true" />
							</query-chunk>
							<query-chunk name="apply_has_bio_filter"
										 sample-value="AND xxx.nb_product_bio > 0">
								<query-chunk-value name="OK"
												   value="AND xxx.nb_product_bio > 0" />
								<query-chunk-value name="NO" value=""
												   is-default="true" />
							</query-chunk>
							<query-chunk name="apply_has_aoc_filter"
										 sample-value="AND xxx.nb_product_aoc > 0">
								<query-chunk-value name="OK"
												   value="AND xxx.nb_product_aoc > 0" />
								<query-chunk-value name="NO" value=""
												   is-default="true" />
							</query-chunk>

						</query-chunks>
					</query>
					<query name="search_freetext" id="search_freetext"
						   package-name="search">
						<query-body>
							<value>
								<![CDATA[
call freetext_search (?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="match" is-mandatory="true" type="string"
										 sample="'win'" todo="m">
								<validations>
									<validation-range-char min='2' />
								</validations>
							</query-param>
							<query-param name="language_code" is-mandatory="true"
										 type="string" sample="'fr'">
								<validations>
									<validation-exist-unique query-id="only_one_value_for_language_code"
															 error-language="en" error="language does not exist" />
								</validations>
							</query-param>
							<query-param name="latitude" is-mandatory="true"
										 type="double" sample="48"></query-param>
							<query-param name="longitude" is-mandatory="true"
										 type="double" sample="7"></query-param>
							<query-param name="entity_filter" is-mandatory="true"
										 type="string" sample="'entity'"></query-param>
							<query-param name="max_results" is-mandatory="true"
										 type="int" sample="7"></query-param>
						</query-params>
					</query>
					<query name="search_winery_freetext" id="search_winery_freetext"
						   package-name="search">
						<query-body>
							<value>
								<![CDATA[
call freetext_search_winery (?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="match" is-mandatory="true" type="string"
										 sample="'winx'"></query-param>
							<query-param name="in_event_id" is-mandatory="true"
										 type="int" sample="1" default-value="-1"></query-param>
							<query-param name="not_in_event_id" is-mandatory="true"
										 type="int" sample="1" default-value="-1"></query-param>
							<query-param name="max_results" is-mandatory="true"
										 type="int" sample="7"></query-param>
						</query-params>
					</query>
					<!-- queries for DDL -->
					<!-- country -> region -> appelation color -> cepage or revert each 
						master data > semantic ref > order by + where parent is (for filter) -->
					<!-- pictures -->

					<!-- suggestions -->
					<query name="cepage_suggestion" id="cepage_suggestion"
						   package-name="suggestion">
						<query-body>
							<value>
								<![CDATA[
 select r.name, r.id, r.longitude_center, r.latitude_center, r.i18n_language_code, 'region' entity from cepage_x_region cr, region r where cr.region_id = r.id and  cr.cepage_id = ?
union
select w.name, w.id, w.longitude, w.latitude, r.i18n_language_code, 'winery' entity
from winery_x_cepage wc, region r, winery w where w.active = true and wc.winery_id = r.id and w.region_id = r.id and wc.cepage_id = ?
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="cepage_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
							<query-param name="cepage_id2" refname="cepage_id"></query-param>
						</query-params>
					</query>

					<query name="last_updated_entities_suggestion" id="last_updated_entities_suggestion"
						   package-name="suggestion">
						<query-body>
							<!-- most recent entities of each category -->
							<value>
								<![CDATA[
select 
    name,
    i18n_language_code language_code,
    '1' AS score,
    s.entity,
    entity_id,
    entity_web_path,
	creation_date,
    last_modification,
    long_lat_entity_id,
    longitude,
    latitude,
    google_zoom,
    0 as distance,
    '1' score_language
from i18n_search s,
(
select max(last_modification) max_last_modification, entity,id
from i18n_search
group by entity 
) m
where s.is_filter is null and s.id = m.id
LIMIT 0 , ?
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="nb_of_result" is-mandatory="true"
										 type="int" sample="2" default-value="10"></query-param>
						</query-params>
					</query>

					<!-- suggestions based on label : input lieu_dit, region, country (filter 
						winery or product specific) <query name="label_suggestion" id="label_suggestion" 
						package-name="suggestion"> <query-body> <value> <![CDATA[ select l.name, 
						l.web_path from ref_label l $wherelieudit $whereregion $wherecountry $whereproductspecific 
						$wherewineryspecific ]]> </value> </query-body> <query-params> <query-param 
						name="cepage_id" is-mandatory="true" type="int" sample="-1"></query-param> 
						<query-param name="cepage_id2" refname="cepage_id"></query-param> </query-params> 
						</query> end suggestions -->

					<query name="winery_picture_list" id="winery_picture_list"
						   package-name="winery">
						<query-body>
							<value>
								<![CDATA[
 select p.id picture_id, image_name, description, display_order, wxp.type
 from picture p, winery_x_picture wxp
 where wxp.picture_id = p.id and wxp.winery_id = ?
 $type
 order by display_order
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="winery_id" is-mandatory="true"
										 type="int" sample="-1"></query-param>
						</query-params>
						<query-chunks>
							<query-chunk name="type" sample-value="and wxp.type='WINERY'">
								<query-chunk-value name="none" value=""
												   is-default="true" />
								<query-chunk-value name="winery"
												   value="and wxp.type='WINERY'" />
								<query-chunk-value name="guest_house"
												   value="and wxp.type='GUEST_HOUSE'" />
							</query-chunk>
						</query-chunks>
					</query>

					<!-- stats -->
					<query name="events_per_year_stat" id="events_per_year_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select 
	ec.id event_country_id, 
	ec.NAME event_country_name, 
	ec.WEB_PATH event_country_web_path, 
	count(*) nb, year 
from event e, country ec, event_organiser eo, contact ect
where 
	e.EVENT_ORGANISER_ID = eo.id
	and eo.CONTACT_ID = ect.id
	and ect.COUNTRY_ID = ec.id
	and e.ACTIVE = true
	$whereYear
	$whereEventCountryWebPath
group by ec.id, year
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereYear" and-where-connection="and">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventCountryWebPath" and-where-connection="and">
								<value><![CDATA[ ec.WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="event_country_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
						<query-pivots>
							<query-pivot name="country" rest="year_stat"
										 columns="event_country_id, event_country_name, event_country_web_path"
										 pivot="event_country_id"></query-pivot>
						</query-pivots>
					</query>

					<query name="events_exhibitors_stat" id="events_exhibitors_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select count(w_ID) NB_OF_EXHIBITORS, 
GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			winery_name,
            winery_web_path,
            region_web_path,
            country_web_path
			)
			order by w_ID
			) exhibitor_details,
count(distinct(e_id)) NB_OF_EVENTS,
GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			event_name,
            event_web_path
			)
			order by e_id
			) Event_details,
PERIOD_BEGINNING, PERIOD_ENDING, PERIOD_NUMBER from
(
select 
	$chunkPeriodGranularity
	w.ID w_id, 
	w.NAME winery_name, 
	w.WEB_PATH winery_web_path,
	r.WEB_PATH region_web_path,
	c.WEB_PATH country_web_path, 
	e.ID e_id, 
	e.name event_name, 
	e.WEB_PATH event_web_path
from event_winery_participation ewp 
 left outer join winery w on ewp.WINERY_ID = w.id 
 $linkGrades
 left outer join event e on ewp.EVENT_ID = e.id
 left outer join region r on w.region_id = r.id
 left outer join country c on r.country_id = c.id
where w.ACTIVE = true
	and ewp.ACTIVE = true
	and e.ACTIVE = true
$whereEventYear
$whereRegionWebPath
$whereCountryWebPath
$whereWineryBio
$whereCepagaWebPath

) xxx group by PERIOD_BEGINNING,PERIOD_ENDING
order by PERIOD_BEGINNING
]]>
							</value>

							<!-- optional to add
							
$wherePeriodBeginning
$wherePeriodEnding
 -->
						</query-body>
						<query-fields>
							<query-field name="exhibitor_details"
										 is-structured-array="true"
										 separator-characters=",|"
										 array-columns="winery_name,winery_web_path,region_web_path,country_web_path"
										 array-columns-type="string,string,string,string">
							</query-field>
							<query-field name="event_details"
										 is-structured-array="true"
										 separator-characters=",|"
										 array-columns="event_name,event_web_path"
										 array-columns-type="string,string">
								<!--  => parts=[{eventName:"", eventWebPath:""...};{}] -->
							</query-field>
						</query-fields>
						<query-chunks>
							<query-chunk name="linkGrades" sample-value="left outer join winery_x_cepage wxc on wxc.winery_id=w.id left outer join cepage cp on wxc.cepage_id = cp.id">
								<query-chunk-value name="none" is-default="true" value="" />
								<query-chunk-value name="true"
												   value="left outer join winery_x_cepage wxc on wxc.winery_id=w.id left outer join cepage cp on wxc.cepage_id = cp.id" />
							</query-chunk>
							<query-chunk name="chunkPeriodGranularity" sample-value="date_add(LAST_DAY(date_add(FROM_DATE,interval -2 month)), interval 1 day) PERIOD_BEGINNING, LAST_DAY(date_add(FROM_DATE,interval -1 month)) PERIOD_ENDING, month(FROM_DATE) PERIOD_NUMBER,">
								<query-chunk-value name="MONTH"
												   value="date_add(LAST_DAY(date_add(FROM_DATE,interval -2 month)), interval 1 day) PERIOD_BEGINNING, LAST_DAY(date_add(FROM_DATE,interval -1 month)) PERIOD_ENDING, month(FROM_DATE) PERIOD_NUMBER," />
								<query-chunk-value name="WEEK" is-default="true"
												   value="SUBDATE(FROM_DATE, WEEKDAY(FROM_DATE)) PERIOD_BEGINNING, DATE(FROM_DATE + INTERVAL (6 - WEEKDAY(FROM_DATE)) DAY) PERIOD_ENDING, weekofyear(FROM_DATE) PERIOD_NUMBER," />
							</query-chunk>
						</query-chunks>
						<query-filters>
							<query-filter name="whereEventYear"
										  and-where-connection="and">
								<value><![CDATA[ e.year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereRegionWebPath"
										  and-where-connection="and">
								<value><![CDATA[ r.web_path = ? ]]></value>
								<query-params>
									<query-param name="region_web_path" type="string" sample="'s'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereCountryWebPath"
										  and-where-connection="and">
								<value><![CDATA[ c.web_path = ? ]]></value>
								<query-params>
									<query-param name="country_web_path" type="string" sample="'s'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereWineryBio"
										  and-where-connection="and">
								<value><![CDATA[ w.is_bio = ? ]]></value>
								<query-params>
									<query-param name="is_winery_bio" type="boolean" sample="true">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereCepagaWebPath"
										  and-where-connection="and" requires-chunks-and-values="linkGrades.true">
								<value><![CDATA[ cp.web_path in (?...) ]]></value>
								<query-params>
									<query-param name="grade_web_paths" type="string" sample="'XXX','YY'" is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="stat_cepage_filters" id="stat_cepage_filters"
						   package-name="stats"
						   is-flat-graph="true"
					>
						<query-body>
							<value>
								<![CDATA[


select * from 
(
select 
	1 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'year' type, 
	null name, 
	null web_path, 
	null flag_icon, 
	concat('y',COUNTRY_ID,'-',cepage_id) id, 
	null parent_id, 
    cepage_id,
	cepage_name,
    cepage_web_path,
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region) - sum(nb_distinct_winery_region_bio) nb_distinct_wineries_not_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region) - sum(nb_exhibitor_region_bio) nb_exhibitors_not_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_cepage_summary
group by event_country_id, cepage_id, year
union
select 
	2 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'country' type, 
	country_name name, 
	country_web_path web_path, 
	country_flag_icon flag_icon, 
	concat('c',COUNTRY_ID,'-',cepage_id) id, 
	null parent_id, 
    cepage_id,
	cepage_name,
    cepage_web_path,
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region) - sum(nb_distinct_winery_region_bio) nb_distinct_wineries_not_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region) - sum(nb_exhibitor_region_bio) nb_exhibitors_not_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_cepage_summary
group by event_country_id, country_id, cepage_id, year
union 
	select 
	3 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'region' type, 
	region_name name, 
	region_web_path web_path, 
	null flag_icon, 
	concat('r',region_ID,'-',cepage_id) id, 
	concat('c',COUNTRY_ID) parent_id, 
	cepage_id,
	cepage_name,
    cepage_web_path,
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region) - sum(nb_distinct_winery_region_bio) nb_distinct_wineries_not_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region) - sum(nb_exhibitor_region_bio) nb_exhibitors_not_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_cepage_summary
group by event_country_id, region_id, cepage_id, year
) xxx
where 1 = 1 
$exists_Bio_NotBio
$whereYear
$whereEventCountryWebPath
$whereWineryCountryWebPath
$whereWineryRegionWebPath
$whereCepageWebPath
$whereType

order by score, type, nb_distinct_wineries desc

]]>
							</value>
						</query-body>
						<!-- 
						=> graph
							ev.type = type  => plurialize list name
							ev.key = id		=> 
							ev.parent_key = parent_id	=> start with parent_id = null
							
							{countries [ name : 'france', ..., regions : [{name : 'alsace', ...},{name : 'bordelais'}]
 							-->
						<query-fields>
							<query-field name="type" is-column-value="true" />
							<query-field name="id" is-key="true" />
							<query-field name="parent_key" is-parent-key="true" />
						</query-fields>
						<query-chunks>
							<query-chunk name="exists_Bio_NotBio" sample-value="and nb_distinct_wineries_bio > 0">
								<query-chunk-value name="NONE" is-default="true" value="" />
								<query-chunk-value name="exists_Bio"
												   value="and nb_distinct_wineries_bio > 0" />
								<query-chunk-value name="exists_NotBio"
												   value="and nb_distinct_wineries_not_bio > 0" />
							</query-chunk>
						</query-chunks>

						<query-filters>
							<query-filter name="whereYear" and-where-connection="and">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventCountryWebPath" and-where-connection="and">
								<value><![CDATA[ event_country_web_path = ? ]]></value>
								<query-params>
									<query-param name="event_country_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereWineryCountryWebPath" and-where-connection="and">
								<value><![CDATA[ web_path = ? and type='country' ]]></value>
								<query-params>
									<query-param name="country_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereWineryRegionWebPath" and-where-connection="and">
								<value><![CDATA[ web_path = ? and type='region' ]]></value>
								<query-params>
									<query-param name="region_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereCepageWebPath" and-where-connection="and">
								<value><![CDATA[ cepage_web_path = ? ]]></value>
								<query-params>
									<query-param name="cepage_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereType" and-where-connection="where">
								<value><![CDATA[ type = ? ]]></value>
								<query-params>
									<query-param name="type" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>

					<query name="stat_filters" id="stat_filters"
						   package-name="stats"
						   is-flat-graph="true"
					>
						<query-body>
							<value>
								<![CDATA[

select * from 
(
select 
	1 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'year' type, 
	null name, 
	null web_path, 
	null flag_icon, 
	concat('y',COUNTRY_ID) id, 
	null parent_id, 
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_summary
group by event_country_id, year
union
select 
	2 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'country' type, 
	country_name name, 
	country_web_path web_path, 
	country_flag_icon flag_icon, 
	concat('c',COUNTRY_ID) id, 
	null parent_id, 
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_summary
group by event_country_id, country_id, year
union 
	select 
	3 score,
	year, 
	event_country_id, 
	event_country_name, 
	event_country_web_path, 
	'region' type, 
	region_name name, 
	region_web_path web_path, 
	null flag_icon, 
	concat('r',region_ID) id, 
	concat('c',COUNTRY_ID) parent_id, 
	sum(nb_distinct_winery_region) nb_distinct_wineries, 
	sum(nb_distinct_winery_region_bio) nb_distinct_wineries_bio, 
	sum(nb_distinct_winery_region_bio_dynamic) nb_distinct_wineries_bio_dynamic,
	sum(nb_exhibitor_region) nb_exhibitors, 
	sum(nb_exhibitor_region_bio) nb_exhibitors_bio, 
	sum(nb_exhibitor_region_bio_dynamic) nb_exhibitors_bio_dynamic 
from v_stat_filter_summary
group by event_country_id, region_id, year
) xxx
$whereYear
$whereEventCountryWebPath
order by score, type, nb_distinct_wineries desc

]]>
							</value>
						</query-body>
						<!-- 
						=> graph
							ev.type = type  => plurialize list name
							ev.key = id		=> 
							ev.parent_key = parent_id	=> start with parent_id = null
							
							{countries [ name : 'france', ..., regions : [{name : 'alsace', ...},{name : 'bordelais'}]
 							-->
						<query-fields>
							<query-field name="type" is-column-value="true" />
							<query-field name="id" is-key="true" />
							<query-field name="parent_key" is-parent-key="true" />
						</query-fields>
						<query-filters>
							<query-filter name="whereYear" and-where-connection="where">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEventCountryWebPath" and-where-connection="where">
								<value><![CDATA[ event_country_web_path = ? ]]></value>
								<query-params>
									<query-param name="event_country_web_path" type="string" sample="'xxx'">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>

					<query name="events_per_week_stat" id="events_per_week_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select count(*) NB, MONDAY_OF_WEEK, SUNDAY_OF_WEEK from
(
select 
SUBDATE(FROM_DATE, WEEKDAY(FROM_DATE)) MONDAY_OF_WEEK, 
DATE(FROM_DATE + INTERVAL (6 - WEEKDAY(FROM_DATE)) DAY) SUNDAY_OF_WEEK
from event 
$whereYear
) xxx group by MONDAY_OF_WEEK,SUNDAY_OF_WEEK
order by MONDAY_OF_WEEK
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereYear"
										  and-where-connection="where">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="wineries_per_event_per_week_stat" id="wineries_per_event_per_week_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select count(*) NB_OF_WINERIES, 
MONDAY_OF_WEEK, 
SUNDAY_OF_WEEK from
(
select w.ID,
SUBDATE(FROM_DATE, WEEKDAY(FROM_DATE)) MONDAY_OF_WEEK, 
DATE(FROM_DATE + INTERVAL (6 - WEEKDAY(FROM_DATE)) DAY) SUNDAY_OF_WEEK
 from winery w, event_winery_participation ewp, event e
where w.ACTIVE = true
and ewp.EVENT_ID = e.id
and ewp.WINERY_ID = w.id
and ewp.ACTIVE = true
$whereYear
) xxx group by MONDAY_OF_WEEK,SUNDAY_OF_WEEK
order by MONDAY_OF_WEEK
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereYear"
										  and-where-connection="and">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="wine_regions_per_event_per_week_stat" id="wine_regions_per_event_per_week_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select count(*) NB_OF_REPRESENTANTS_OF_WINE_REGIONS, 
region_name,
MONDAY_OF_WEEK, 
SUNDAY_OF_WEEK from
(
select r.name region_name,
SUBDATE(FROM_DATE, WEEKDAY(FROM_DATE)) MONDAY_OF_WEEK, 
DATE(FROM_DATE + INTERVAL (6 - WEEKDAY(FROM_DATE)) DAY) SUNDAY_OF_WEEK
 from winery w, event_winery_participation ewp, event e, region r
where w.ACTIVE = true
and ewp.EVENT_ID = e.id
and ewp.WINERY_ID = w.id
and ewp.ACTIVE = true
and w.REGION_ID = r.ID
$whereYear
) xxx group by region_name, MONDAY_OF_WEEK,SUNDAY_OF_WEEK
order by MONDAY_OF_WEEK
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereYear"
										  and-where-connection="and">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="wine_countries_per_event_per_week_stat" id="wine_countries_per_event_per_week_stat"
						   package-name="stats">
						<query-body>
							<value>
								<![CDATA[
select count(*) NB_OF_REPRESENTANTS_OF_WINE_COUNTRY, 
country_web_path,
MONDAY_OF_WEEK, 
SUNDAY_OF_WEEK from
(
select c.web_path country_web_path,
SUBDATE(FROM_DATE, WEEKDAY(FROM_DATE)) MONDAY_OF_WEEK, 
DATE(FROM_DATE + INTERVAL (6 - WEEKDAY(FROM_DATE)) DAY) SUNDAY_OF_WEEK
 from winery w, event_winery_participation ewp, event e, region r, country c
where w.ACTIVE = true
and ewp.EVENT_ID = e.id
and ewp.WINERY_ID = w.id
and ewp.ACTIVE = true
and w.REGION_ID = r.ID
and r.COUNTRY_ID = c.id
$whereYear
) xxx group by country_web_path, MONDAY_OF_WEEK,SUNDAY_OF_WEEK
order by MONDAY_OF_WEEK
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereYear"
										  and-where-connection="and">
								<value><![CDATA[ year = ? ]]></value>
								<query-params>
									<query-param name="year" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>


					<!-- stats end -->
					<query name="winery_region_summary" id="winery_region_summary"
						   package-name="winery">
						<query-body>
							<value>
								<![CDATA[
select c.name country_name, c.web_path country_web_path, r.name region_name, r.web_path region_web_path, 
count(r.id) nb_wineries_per_region from winery w, region r, country c where
w.REGION_ID = r.id and c.id = r.country_id
and w.ACTIVE = true
group by r.name, r.web_path
order by c.name, r.name
]]>
							</value>
						</query-body>
					</query>

					<query name="winery_country_summary" id="winery_country_summary"
						   package-name="winery">
						<query-body>
							<value>
								<![CDATA[
select c.name country_name, c.web_path country_web_path, count(c.id) nb_wineries_per_country from winery w, region r, country c where
w.REGION_ID = r.id and c.id = r.country_id
and w.ACTIVE = true
group by c.name, c.web_path
order by c.name
]]>
							</value>
						</query-body>
					</query>

					<!-- SDD for public -->
					<!-- search type wine/region/country ex: cabernet // try content search 
						on tags / grades / region / country / (domain) =>list of wines + domains -->

					<!-- pay plan display TODO remove generated code <query name="pivot 
						chosen pay plan condition" id="pivot-chosen-pay-plan-condition" package-name="pay_plan"> 
						<query-body> <value> <![CDATA[ select ppp.pay_plan_name, ppp.pay_plan_description, 
						ppp.pay_plan_price price, ppp.register_date register_date, ppp.activation_date, 
						ppp.end_activation_date, concat('payplan.',pppc.name) pay_plan_condition_i18n_entry, 
						pppc.name, pppc.condition_description, pppc.display_number, pppc.quantity 
						from profile_pay_plan ppp, profile_pay_plan_condition pppc, user_winery_profile 
						uwp where uwp.PROFILE_PAY_PLAN_ID = ppp.ID and pppc.PROFILE_PAY_PLAN_ID = 
						ppp.ID and uwp.winery_id = ? order by pppc.DISPLAY_NUMBER ]]> </value> </query-body> 
						<query-pivots> <query-pivot name="profilePayPlan" columns="pay_plan_name, 
						pay_plan_description, price, register_date, activation_date, end_activation_date" 
						pivot="pay_plan_name"></query-pivot> <query-pivot name="profilecondition" 
						columns="name, condition_description, quantity, pay_plan_condition_i18n_entry" 
						pivot="name"></query-pivot> </query-pivots> <query-params> <query-param name="winery_id" 
						is-mandatory="true" type="int" sample="-1" from-profile-session-property="winery_id"></query-param> 
						</query-params> </query> -->
					<query name="pivot pay plan condition" id="pivot-pay-plan-condition"
						   package-name="pay_plan">
						<query-body>
							<value>
								<![CDATA[
select pp.price price, pp.name pay_plan_name, pp.description pay_plan_description, pp.id pay_plan_id, pp.period,
ppxc.quantity quantity, ppc.name condition_name, concat('payplan.',ppc.name) pay_plan_condition_i18n_entry, ppc.condition_description condition_description, ppc.id pay_plan_condition_id
from pay_plan pp, pay_plan_x_condition ppxc, pay_plan_condition ppc
where
ppxc.pay_plan_id = pp.id
and ppxc.pay_plan_condition_id = ppc.id
order by pp.display_order, ppc.display_number
]]>
							</value>
						</query-body>
						<query-pivots>
							<query-pivot name="pay_plan"
										 columns="pay_plan_name, pay_plan_description, pay_plan_id, price"
										 pivot="pay_plan_id"></query-pivot>
							<query-pivot name="condition"
										 columns="condition_description, quantity, pay_plan_condition_i18n_entry"
										 pivot="pay_plan_condition_id"></query-pivot>
						</query-pivots>

					</query>

					<query name="pay plan condition matrix" id="pay-plan-condition-matrix"
						   package-name="pay_plan" cache="true" content-type="reference-data">
						<!-- create pivot classes film and actor once processed reassemble 
							g -->
						<query-body> <!-- dimensions column first -->
							<value>
								<![CDATA[
select cond , pay_plan_condition_i18n_entry,
      sum(case when pay_plan_id = 1 then match_ end) free_offer,
      sum(case when pay_plan_id = 1 then quantity end) free_offer_quantity,
      sum(case when pay_plan_id = 2 then match_ end) intermediate_offer,
      sum(case when pay_plan_id = 2 then quantity end) intermediate_offer_quantity,
      sum(case when pay_plan_id = 3 then match_ end) pro_offer,
      sum(case when pay_plan_id = 3 then quantity end) pro_offer_quantity
from v_apply_ppc
group by cond, pay_plan_condition_i18n_entry
order by order_number asc
]]>
							</value>
						</query-body>
						<!-- <query-display result-row-display="first_name, last_name"/> -->
					</query>

					<query name="pay plan price" id="pay-plan-price"
						   package-name="pay_plan">
						<!-- create pivot classes film and actor once processed reassemble 
							g -->
						<query-body> <!-- dimensions column first -->
							<value>
								<![CDATA[
select sum(free_offer_price) free_offer_price
	  ,sum(intermediate_offer_price) intermediate_offer_price
      ,sum(pro_offer_price) pro_offer_price
from (
select (case when id = 1 then price end) free_offer_price
	  ,(case when id = 2 then price end) intermediate_offer_price
	  ,(case when id = 3 then price end) pro_offer_price
from pay_plan
) xxx
]]>
							</value>
						</query-body>
						<!-- <query-display result-row-display="first_name, last_name"/> -->
					</query>

					<query name="application_param" id="application_param"
						   package-name="application">
						<query-body> <!-- dimensions column first -->
							<value>
								<![CDATA[
select * from conf_param where sensitivity = 'PUBLIC'
]]>
							</value>
						</query-body>
					</query>
					<!-- EVENT end -->
					<!-- GENERIC DDL -->
					<query name="ddl_With_Extra" id="ddl_With_Extra"
						   package-name="generic" cache="true">
						<query-body>
							<value>
								<![CDATA[
select $key as key_, $value as value, $extra as extra
from $entity_name
$whereChunk
order by $order asc
	]]>
							</value>
						</query-body>
						<!-- <query-params> <query-param id="id" name="id" is-mandatory="true" 
							type="int" sample="48"></query-param> </query-params> -->
						<query-chunks>
							<query-chunk name="key" sample-value="name"> <!-- it is just to have string instead of int as output -->
							</query-chunk>
							<query-chunk name="value" sample-value="name">
							</query-chunk>
							<query-chunk name="extra" sample-value="name">
							</query-chunk>
							<query-chunk name="whereChunk">
								<query-chunk-params>
									<query-chunk-param id="id" name="id" type="int"
													   sample="48"></query-chunk-param>
									<query-chunk-param id="languageCode" name="language_code"
													   type="string" sample="'EN'"></query-chunk-param>
								</query-chunk-params>
								<query-chunk-value name="none" value=""
												   is-default="true" />
								<query-chunk-value name="whereRobe"
												   value="where parent_color_id is not null" />
								<query-chunk-value name="whereRobeParent"
												   value="where parent_color_id = ?" params="id" />
								<query-chunk-value name="whereBase"
												   value="where parent_color_id is null" />
								<query-chunk-value name="whereCountryId"
												   value="where country_id = ?" params="id" />
								<query-chunk-value name="whereLanguage"
												   value="where i18n_language_code = ?" params="language_code" />
							</query-chunk>
							<query-chunk name="entity_name" sample-value="ref_appelation_classification">
								<!-- TODO Add by security all the table <query-chunk-value name="appelation_classification" 
									value="ref_appelation_classification" /> -->
							</query-chunk>
							<query-chunk name="order" sample-value="name">
							</query-chunk>
						</query-chunks>
					</query>
					<query name="ddl" id="ddl" package-name="generic" cache="true">
						<query-body>
							<value>
								<![CDATA[
select $key as key_, $value as value
from $entity_name
$wherecountry $wherelanguage
order by $order asc
	]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="wherecountry"
										  and-where-connection="where">
								<value><![CDATA[ country_id = ? ]]></value>
								<query-params>
									<query-param name="country_id" type="int" sample="-1">
									</query-param>
								</query-params>
							</query-filter>
							<!-- TODO remove from execution <query-filter name="whereappelationclassification" 
								and-where-connection="where"> <value><![CDATA[ ref_appelation_classification 
								= ? ]]></value> <query-params> <query-param name="appelation_classification_id" 
								type="int" sample="-1"> </query-param> </query-params> </query-filter> -->
							<query-filter name="wherelanguage"
										  and-where-connection="where">
								<value><![CDATA[ i18n_language_code = ? ]]></value>
								<query-params>
									<query-param name="language_code" type="string"
												 sample="'EN'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-chunks>
							<query-chunk name="key" sample-value="name"> <!-- it is just to have string instead of int as output -->
							</query-chunk>
							<query-chunk name="value" sample-value="name">
							</query-chunk>
							<query-chunk name="entity_name" sample-value="ref_appelation_classification">
							</query-chunk>
							<query-chunk name="order" sample-value="name">
							</query-chunk>
						</query-chunks>
					</query>


					<!-- end security -->
					<!-- description language -->
					<query name="description_language" id="description_language"
						   package-name="description" is-deprecated=""><!-- no REST /upto service
							level -->
						<query-body>
							<value>
								<![CDATA[
select bd.id, bd.description, bd.i18n_language_code language_code from i18n_business_description bd
$scope
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="winery_id" session-param-name="wineryId"
										 is-implicit="true" is-mandatory="true" type="int" sample="-1"></query-param>
						</query-params>
						<query-chunks>
							<query-chunk name="scope" sample-value="where bd.winery_id=?">
								<query-chunk-value name="winery" value=""
												   is-default="where bd.winery_id=?" />
								<query-chunk-value name="product"
												   value=", product p where bd.product_id = p.id and p.winery_id = ?" />
								<query-chunk-value name="guest_house"
												   value=", guest_house gh where bd.guest_house_id = gh.id and gh.winery_id = ?" />
							</query-chunk>
						</query-chunks>
					</query>

					<query name="system_info" id="system_info" package-name="developer">
						<query-body>
							<value>
								<![CDATA[
select param_key, param_value from conf_Param where param_key in ('SERVER_ROOT_URL','SITE_PUBLIC_API','SITE_PUBLIC_API_SAMPLE_CLIENT')
]]>
							</value>
						</query-body>
					</query>
					<!-- Translation -->
					<query name="translation_set" id="translation_set"
						   package-name="translation">
						<query-body>
							<value>
								<!-- select t1.id id_level1, t1.entry entry_level1, v1.value value_level1, 
									t2.id id_level2, t2.entry entry_level2, v2.value value_level2 from ms_translation_entry 
									t1 left outer join ms_translation_entry t2 on t2.parent_id = t1.id left join 
									( select i18n_translation_entry_id, value from ms_translation_value where 
									i18n_language_code = ? ) v1 on v1.i18n_translation_entry_id = t1.id left 
									join ( select i18n_translation_entry_id, value from ms_translation_value 
									where i18n_language_code = ? ) v2 on v2.i18n_translation_entry_id = t2.id 
									where t1.parent_id is null -->
								<!-- TODO change with with clause in mysql version 8 Add multiple 
									language and default definition in english -->
								<![CDATA[

select t1.id id_level1, t1.entry entry_level1, v1.value value_level1, 
t2.id id_level2, t2.entry entry_level2, v2.value value_level2 
from ms_translation_entry t1 
left outer join ms_translation_entry t2 on t2.parent_id = t1.id 
left join 
 (
 
 select zzz.i18n_translation_entry_id, zzz.value
from
(
select xxx.i18n_translation_entry_id, max(xxx.score) max_score from
(
select id, i18n_translation_entry_id, value, case when i18n_language_code = 'EN' then 0 else 1 end score 
from ms_translation_value where i18n_language_code in ('EN', ?)
) xxx
group by xxx.i18n_translation_entry_id
) yyy, 
(
select id, i18n_translation_entry_id, value, case when i18n_language_code = 'EN' then 0 else 1 end score 
from ms_translation_value where i18n_language_code in ('EN', ?)
) zzz
where yyy.i18n_translation_entry_id = zzz.i18n_translation_entry_id and max_score = zzz.score
 
 ) v1 on v1.i18n_translation_entry_id = t1.id
left join 
 ( 
 
select zzz.i18n_translation_entry_id, zzz.value
from
(
select xxx.i18n_translation_entry_id, max(xxx.score) max_score from
(
select id, i18n_translation_entry_id, value, case when i18n_language_code = 'EN' then 0 else 1 end score 
from ms_translation_value where i18n_language_code in ('EN', ?)
) xxx
group by xxx.i18n_translation_entry_id
) yyy, 
(
select id, i18n_translation_entry_id, value, case when i18n_language_code = 'EN' then 0 else 1 end score 
from ms_translation_value where i18n_language_code in ('EN', ?)
) zzz
where yyy.i18n_translation_entry_id = zzz.i18n_translation_entry_id and max_score = zzz.score
 
 ) v2 on v2.i18n_translation_entry_id = t2.id
where t1.parent_id is null
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="language" is-mandatory="true"
										 type="string" sample="'win'"></query-param>
							<query-param name="language2" refname="language"></query-param>
							<query-param name="language3" refname="language"></query-param>
							<query-param name="language4" refname="language"></query-param>
						</query-params>
						<query-pivots>
							<query-pivot name="module"
										 columns="id_level1, entry_level1, value_level1" pivot="id_level1"></query-pivot>
							<query-pivot name="entry"
										 columns="id_level2, entry_level2, value_level2" pivot="id_level2"></query-pivot>
						</query-pivots>
					</query>
					<query name="translation_language" id="translation_language"
						   package-name="translation">
						<query-body>
							<value>
								<![CDATA[
select code, name as language, idiom, locale, flag_icon from i18n_language
$whereistranslated $whereistotranslate
order by display_order
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereistranslated"
										  and-where-connection="where">
								<value><![CDATA[ ms_trans_is_translated = ? ]]></value>
								<query-params>
									<query-param name="is_translated" type="boolean"
												 sample="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereistotranslate"
										  and-where-connection="where">
								<value><![CDATA[ ms_trans_is_to_translate = ? ]]></value>
								<query-params>
									<query-param name="is_to_translate" type="boolean"
												 sample="true">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="dummy_auth" id="dummy_auth" package-name="dummy">
						<query-body>
							<value>
								<![CDATA[
select first_name, last_name from user 
where email = ? 
$wherepassword
limit 1
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="email" is-mandatory="true" type="string"
										 sample="'winx'"></query-param>
						</query-params>
						<query-filters>
							<query-filter name="wherepassword"
										  and-where-connection="and">
								<value><![CDATA[ password = ? ]]></value>
								<query-params>
									<query-param name="password" type="string" sample="'sqfd'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
				</queries>
				<composites>
					<!-- public for winery overview -->
					<composite name="winery_overview_card" id="winery_overview_card"
							   package-name="winery">
						<queries>
							<query refid="winery_public" result-cardinality="one"
								   holder="false"></query>
							<query refid="winery_product_item_badge"
								   result-cardinality="many" holder="false"></query>
						</queries>
						<composite-params>
							<!-- 1) if params specified => param as input otherwise implicit params 
								2) /package 3) remove in out holder 4) use cardinality -->
							<query-param name="winery_id" is-mandatory="true"
										 type="int" sample="-1" is-id="true"></query-param>
							<query-param name="web_path" is-mandatory="true"
										 type="string" sample="'xx'" is-id="true"></query-param>
						</composite-params>
					</composite>

					<composite name="stats_info" id="stats_info"
							   package-name="stats">
						<queries>
							<!-- -->
							<query refid="events_per_year_stat" result-cardinality="many" holder="false"></query>

							<query refid="events_per_week_stat" result-cardinality="many" holder="false"></query>
							<query refid="wineries_per_event_per_week_stat" result-cardinality="many" holder="false"></query>
							<query refid="wine_regions_per_event_per_week_stat" result-cardinality="many" holder="false"></query>
							<query refid="wine_countries_per_event_per_week_stat" result-cardinality="many" holder="false"></query>
						</queries>
						<composite-params>
							<!-- 1) if params specified => param as input otherwise implicit params 
								2) /package 3) remove in out holder 4) use cardinality -->
							<query-param name="year" is-mandatory="true"
										 type="int" sample="-1" is-id="true"></query-param>
						</composite-params>
					</composite>

				</composites>
			</statement-model>
		</model>

		<targets catalog-entry="REST-Kendoui, Ember"
				 append-catalog-entry-dir-to-outputdir-root="true"
				 outputdir-root="../../product/winy-public-api">
			<property name="ember-octane" value="false" />
			<property name="openxava-disable-sdd" value="true" />
			<property name="environment" value="remote" />
			<property name="show-sql" value="false" />

			<property name="filter-cors" value="apache" />
			<property name="swagger" value="true" />
			<property name="botdetect" value="true" />
			<property name="velocity-enabled" value="true" />

			<property name="setter-return-instance" value="true" />
			<property name="add-named-queries" value="false" />

			<property name="target-server" value="tomcat" />
			<!-- -->
			<property name="mail-server" value="mailgun">
				<property name="mail.smtps.host" value="smtp.mailgun.org" />
				<property name="mail.smtps.auth" value="true" />
				<property name="mail.smtp.socketFactory.class" value="javax.net.ssl.SSLSocketFactory" />
				<property name="mail.smtp.starttls.enable" value="true" />
				<property name="mail.smtp.ssl.trust" value="smtp.mailgun.org" />

				<property name="username" value="postmaster@winerylabs.com" />
				<property name="password" value="5155c8411cb29829e715462bbd3cf878" />
				<property name="url" value="smtp.mailgun.com" />
			</property>

			<property name="maven-dependencies">
				<property name="gson"
						  value="group: 'com.google.code.gson', name: 'gson', version: '2.2.4'" />
				<property name="jbcrypt"
						  value="group: 'org.mindrot', name: 'jbcrypt', version: '0.4'" />
				<property name="velocity"
						  value="group: 'org.apache.velocity', name: 'velocity', version: '1.7'" />
				<property name="velocity-tools"
						  value="group: 'org.apache.velocity', name: 'velocity-tools', version: '2.0'" />
				<property name="velocity-tools"
						  value="group: 'org.json', name: 'json', version: '20190722'" />
				<property name="itextpdf"
						  value="group: 'com.itextpdf', name: 'itextpdf', version: '5.5.13'" />
				<property name="itextpdf-xmlworker"
						  value="group: 'com.itextpdf.tool', name: 'xmlworker', version: '5.5.13'" />

				<property name="org.json"
						  value="group: 'org.json', name: 'json', version: '20180813'" />
				<property name="org.apache.velocity-velocity"
						  value="group: 'org.apache.velocity', name: 'velocity', version: '1.7'" />
				<property name="org.apache.velocity-tools"
						  value="group: 'org.apache.velocity', name: 'velocity-tools', version: '2.0'" />
				<!-- <property name="javax.mail" value="group: 'javax.mail', name: 'mail', 
					version: '1.5.0-b01'"/> -->
			</property>

			<property name="disable-sass-maven-plugin" value="true" />

		</targets>


	</configuration>
</generator-config>
