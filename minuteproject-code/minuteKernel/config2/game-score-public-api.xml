<!DOCTYPE root>
<!--
TODO MP improvements:
- injected queries (ex with distinct <- injectee)
- POST matrix => as a sql with ( ) xx table
- groupby in java lambda to have nested objects OTB
-->
<generator-config>
	<configuration>
		<conventions>
			<!-- <target-convention type="enable-updatable-code-feature" /> -->
			<target-convention type="disable-timestamp-comment-marker" />
			<target-convention type="disable-business-model-generation" />
		</conventions>
		<model name="score" version="${version}" package-root="com.game">
			<description>
				<CDATA>
					This model illustrates:
					Reverse-engineering on tables, views
					SDD
					Add ad-hoc forms and actions
				</CDATA>
			</description>
			<data-model database-type="MYSQL">
				<driver name="mysql" version="8.0.19" groupId="mysql"
					artifactId="mysql-connector-java"></driver>
				<dataSource>
					<driverClassName>com.mysql.cj.jdbc.Driver</driverClassName>
					 
					<url>${jdbcUrl}</url>
					<username>${username}</username>
					<password>${password}</password>

				</dataSource>
				<!-- for Oracle and DB2 please set the schema <schema> </schema> -->
				<primaryKeyPolicy oneGlobal="true">
					<primaryKeyPolicyPattern name="autoincrementPattern"></primaryKeyPolicyPattern>
				</primaryKeyPolicy>
			</data-model>
			<statement-model>
				<enrichment>
					<conventions>
						<!-- no yet finished <sdd-pagination-convention pattern="_list" type="apply-pagination-only-to-query-ending-with" 
							add-param-default="false"/>
							game,score,team,timeline,program,participant,distinct,sitemap,property
							-->
						<sdd-content-type-convention pattern=""
							type="apply-content-type-to-entity-not-belonging-to-package"
							content-type="master-data" />					
 						<sdd-cache-convention pattern="master-data"
							type="apply-cache-to-content-type" />
						<sdd-cache-convention pattern="reference-data"
							type="apply-cache-to-content-type" />
					</conventions>
				</enrichment>
				<queries>
					<!-- sitemap queries -->
					<query name="sitemap" id="sitemap"
						   package-name="sitemap">
						<query-body>
							<value>
								select * from v_sitemap order by score
							</value>
						</query-body>
						<query-schedulers><!-- schedulers are actions + scheduling and reporting
								=> extends action -->
							<!--
                            * "0 0 * * * *" = the top of every hour of every day.
                            * "*/10 * * * * *" = every ten seconds.
                            * "0 0 8-10 * * *" = 8, 9 and 10 o'clock of every day.
                            * "0 0 8,10 * * *" = 8 and 10 o'clock of every day.
                            * "0 0/30 8-10 * * *" = 8:00, 8:30, 9:00, 9:30 and 10 o'clock every day.
                            * "0 0 9-17 * * MON-FRI" = on the hour nine-to-five weekdays
                            * "0 0 0 25 12 ?" = every Christmas Day at midnight
                            -->
							<query-scheduler name="process_sitemap"
											 cron="0 1 1 * * ?" report-channel="mailgun" report-from="thewineryproject@gmail.com"
											 report-to="thewineryproject@gmail.com"
											 report-copy-file-to="/opt/tomcat/myapp/kls/sitemaps/sitemap.xml"
											 report-copy-file-to-dir="/opt/tomcat/kls/winy/sitemaps"
											 report-threshold-min-record="1"
											 report-template-type="velocity"
											 report-template-name="sitemap.xml.vm">
							</query-scheduler>
						</query-schedulers>
					</query>
					<query name="sitemap_param" id="sitemap_param"
						   package-name="sitemap">
						<query-body>
							<value>
								select
									entity_id,
									entity_path,
									business_entity_path,
									business_path,
									name,
									root_entity_path,
									root_path
								from v_sitemap_param_core
									$whereBusinessEntityPath
									$whereRootEntityPath
									$whereName
								order by score
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereBusinessEntityPath" and-where-connection="where">
								<value><![CDATA[ business_entity_path = ? ]]></value>
								<query-params>
									<query-param name="business_entity_path" type="string" sample="'game'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereRootEntityPath" and-where-connection="where">
								<value><![CDATA[ root_entity_path = ? ]]></value>
								<query-params>
									<query-param name="root_entity_path" type="string" sample="'programme'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereName" and-where-connection="where">
								<value><![CDATA[ name like ? ]]></value>
								<query-params>
									<query-param name="name" type="string" sample="'a'" >
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="distinct_sitemap_type" id="distinct_sitemap_type"
						   package-name="sitemap">
						<query-body>
							<value>
								select distinct
									root_entity_path,
									business_entity_path
								from v_sitemap_param
							</value>
						</query-body>
					</query>
<!-- duplicate to remove
					<query name="sitemap_param" id="sitemap_param"
						   package-name="sitemap">
						<query-body>
							<value>
								select
								entity_id,
								entity_path,
								business_entity_path,
								business_path,
								name,
								root_entity_path,
								root_path
								from v_sitemap_param_core
								$whereBusinessEntityPath
								$whereRootEntityPath
								$whereName
								order by score
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereBusinessEntityPath" and-where-connection="where">
								<value><![CDATA[ business_entity_path = ? ]]></value>
								<query-params>
									<query-param name="business_entity_path" type="string" sample="'game'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereRootEntityPath" and-where-connection="where">
								<value><![CDATA[ root_entity_path = ? ]]></value>
								<query-params>
									<query-param name="root_entity_path" type="string" sample="'programme'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereName" and-where-connection="where">
								<value><![CDATA[ name like ? ]]></value>
								<query-params>
									<query-param name="name" type="string" sample="'a'" >
										<property name="like-mode" value="contains"></property>
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
-->

					<!-- quizz -->
					<query name="quizz_participation_filter_matrix" id="quizz_participation_filter_matrix"
						   package-name="quizz">
						<query-body>
							<!-- add a random value to sort -->
							<!-- side effect error when nb of winner > 3 to fix by limiting via chunks 'and not exists' -->
							<value>
								select
									distinct
									pg.edition_number,
									pg.name program_name,
									pg.web_path program_web_path,
									g.time_position,
									g.name game_name,
									g.web_path game_web_path
								from
									gs_program pg,
									gs_game g,
									gs_participant_x_game pxg,
									gs_game_participation_type gpt
								where
									g.gs_program_id = pg.id and
									pxg.GS_GAME_ID = g.ID and
									pxg.gs_game_participation_type_id = gpt.id
									$whereProgramWebPath
									$whereGameTypeWebPath
									$whereParticipationTypeWebPath
								order by pg.edition_number desc, g.time_position asc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameTypeWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipationTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gpt.web_path = ? ]]></value>
								<query-params>
									<query-param name="participation_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="quizz_winner_team_matrix" id="quizz_winner_team_matrix"
						   package-name="quizz">
						<query-body>
							<value>
							select
								p.name program_name,
								p.web_path program_web_path,
								g.name game_name,
								g.web_path game_web_path
							from
								gs_game g, gs_program p
							where
								g.GS_PROGRAM_ID = p.ID
								and exists (
									select txg.GS_GAME_ID, count(*) from gs_team t, gs_team_x_game txg
									where t.ID = txg.GS_TEAM_ID and g.ID = txg.GS_GAME_ID
									group by txg.GS_GAME_ID
									having count(*) > 1
								)
							$whereProgramWebPath
							order by program_name, game_name
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-pagination max-result-param="limit"
										  offset-param="offset"></query-pagination>
					</query>
					<query name="quizz_winner_team_option" id="quizz_winner_team_option"
						   package-name="quizz">
						<query-body>
							<value>
							select
								p.name program_name,
								p.web_path program_web_path,
								g.name game_name,
								g.web_path game_web_path,
								t.name team_name,
								t.web_path team_web_path,
								ranking,
								case when ranking = 1 then 1 else RAND(6) end as score
							from
								gs_game g, gs_team t, gs_team_x_game txg, gs_program p
							where
								t.ID = txg.GS_TEAM_ID and g.ID = txg.GS_GAME_ID and g.GS_PROGRAM_ID = p.ID
								and exists (
									select txg.GS_GAME_ID, count(*) from gs_team t, gs_team_x_game txg
									where t.ID = txg.GS_TEAM_ID and g.ID = txg.GS_GAME_ID
									group by txg.GS_GAME_ID
									having count(*) > 1
								)
								$whereProgramWebPath
								$whereGameWebPath
								$whereRanking
								order by program_name, game_name, score desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereRanking" and-where-connection="and">
								<value><![CDATA[ ranking = ? ]]></value>
								<query-params>
									<query-param name="ranking" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-pagination max-result-param="limit"
										  offset-param="offset"></query-pagination>
					</query>
					<query name="quizz_participation_option" id="quizz_participation_option"
						   package-name="quizz">
						<query-body>
							<!-- add a random value to sort -->
							<value>
								select
									pl.name participant_name,
									pl.web_path participant_web_path,
									g.name game_name,
									g.web_path game_web_path,
									pg.name program_name,
									pg.web_path program_web_path,
									ranking,
									case when ranking = 1 then 1 else RAND(6) end as score
								from
									gs_player pl,
									gs_participant pa,
									gs_program pg,
									(
									 	select g.*, count(*) nb_of_winners from gs_game g, gs_participant_x_game pxg
										where pxg.GS_GAME_ID = g.ID and pxg.ranking = 1
										group by g.ID
									) g,
									gs_team t,
									gs_participant_x_game pxg,
									gs_game_participation_type gpt
								where
									pa.gs_player_id = pl.id and
									pa.gs_program_id = pg.id and
									pxg.gs_team_id = t.id and
									pxg.GS_GAME_ID = g.ID and
									pxg.GS_PARTICIPANT_ID = pa.ID and
									g.gs_program_id = pg.id and
									pxg.gs_game_participation_type_id = gpt.id

								$whereMaxWinners
								$whereProgramWebPath
								$whereGameWebPath
								$whereParticipationTypeWebPath
								$whereParticipantWebPathIn
								$whereRanking
								order by score desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereMaxWinners" and-where-connection="and">
								<value><![CDATA[ g.nb_of_winners <= ? ]]></value>
								<query-params>
									<query-param name="max_winners" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>

							<query-filter name="whereParticipationTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gpt.web_path = ? ]]></value>
								<query-params>
									<query-param name="participation_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipantWebPathIn" and-where-connection="and">
								<value><![CDATA[ pl.web_path in (?...) ]]></value>
								<query-params>
									<query-param name="participant_web_paths" type="string" sample="'test'" is-in-clause="true">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereRanking" and-where-connection="and">
								<value><![CDATA[ ranking = ? ]]></value>
								<query-params>
									<query-param name="ranking" type="int" sample="1">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-pagination max-result-param="limit"
										  offset-param="offset"></query-pagination>
					</query>

					<query name="quizz_winner_participant_order_filter_matrix" id="quizz_winner_participant_order_filter_matrix"
						   package-name="quizz">
						<query-body>
							<!-- TODO MP : for distinct add concept of injected query -->
							<value>
								<![CDATA[
select distinct
game_name,
game_web_path,
program_name,
program_web_path
from
	(
	select
		g.name game_name,
		g.web_path game_web_path,
		pg.name program_name,
		pg.web_path program_web_path,
		pg.edition_number,
		g.time_position,
		pl.name participant_name,
		pl.web_path participant_web_path

	from
		gs_participant_x_game pxg,
		gs_game g,
		gs_program pg,
		gs_participant p,
		gs_player pl,
		gs_game_participation_type gpt
	where
		pxg.gs_game_id = g.ID and
		pxg.GS_PARTICIPANT_ID = p.ID and
		g.gs_program_id = pg.ID and
		p.GS_PLAYER_ID = pl.ID and
		g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
		gpt.WEB_PATH = 'individuel' and
		pxg.RANKING between 1 and 3
		and g.ID in (select g.ID from gs_participant_x_game pxg, gs_game g
			where pxg.GS_GAME_ID = g.ID and pxg.RANKING < 4 and pxg.RANKING > 0
			group by g.id
			having count(*) between 2 and 3
		)
		$whereProgramWebPath
		$whereGameWebPath
	) xx
order by edition_number desc, time_position asc
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="quizz_winner_team_order_filter_matrix"
						   package-name="quizz">
						<query-body>
							<!-- TODO MP : for distinct add concept of injected query: injectee -->
							<value>
								<![CDATA[
select distinct
	program_name,
	program_web_path,
	game_name,
    game_web_path
from (
select
	pg.name program_name,
    pg.web_path program_web_path,
    pg.EDITION_NUMBER,
	g.name game_name,
    g.web_path game_web_path,
    g.TIME_POSITION,
	t.name team_name,
    t.web_path team_web_path,
    txg.ranking ranking
 from
gs_team_x_game txg,
gs_game g,
gs_team t,
gs_program pg,
gs_game_participation_type gpt
where
txg.gs_game_id = g.ID and
txg.GS_TEAM_ID = t.ID and
g.gs_program_id = pg.ID and
g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
gpt.WEB_PATH = 'collectif' and
txg.RANKING between 1 and 3
and g.ID in (select g.ID from gs_team_x_game txg, gs_game g
 	where txg.GS_GAME_ID = g.ID and txg.RANKING < 4 and txg.RANKING > 0
    group by g.id
    having count(*) between 2 and 3
 )
$whereProgramWebPath
$whereGameWebPath
) xx
order by edition_number desc, time_position asc
								]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="quizz_sort_team_member_filter_matrix"
						   package-name="quizz">
						<query-body>
							<!-- TODO MP : for distinct add concept of injected query: injectee -->
							<value>
								<![CDATA[
select distinct
	program_name,
	program_web_path,
	game_name,
    game_web_path
from (
select
	pg.name program_name,
    pg.web_path program_web_path,
    pg.EDITION_NUMBER,
	g.name game_name,
    g.web_path game_web_path,
    g.TIME_POSITION,
	t.name team_name,
    t.web_path team_web_path,
    pl.name participant_name,
    pl.web_path participant_web_path,
    gat.WEB_PATH game_activity_type_web_path
 from
	gs_participant_x_game pxg,
	gs_game g,
	gs_team t,
	gs_program pg,
	gs_game_participation_type gpt,
	gs_game_activity_type gat,
	gs_participant pa,
	gs_player pl
where
	pxg.gs_game_id = g.ID and
	pxg.gs_team_id = t.ID and
	pxg.GS_PARTICIPANT_ID = pa.ID and
	pxg.GS_GAME_ACTIVITY_TYPE_ID = gat.ID and
	pa.GS_PLAYER_ID = pl.ID and
	g.gs_program_id = pg.ID and
	g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
	gpt.WEB_PATH = 'collectif'
$whereProgramWebPath
$whereGameWebPath
) xx
order by edition_number desc, time_position asc
								]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<!-- quizz matrix end -->
					<query name="quizz_sort_team_member_option" id="sort_team_member_option"
						   package-name="quizz">
						<query-body>
							<value>
								<![CDATA[
select
	pg.name program_name,
    pg.web_path program_web_path,
    pg.EDITION_NUMBER,
	g.name game_name,
    g.web_path game_web_path,
    g.TIME_POSITION,
	t.name team_name,
    t.web_path team_web_path,
    pl.name participant_name,
    pl.web_path participant_web_path,
    gat.WEB_PATH game_activity_type_web_path
 from
	gs_participant_x_game pxg,
	gs_game g,
	gs_team t,
	gs_program pg,
	gs_game_participation_type gpt,
	gs_game_activity_type gat,
	gs_participant pa,
	gs_player pl
where
	pxg.gs_game_id = g.ID and
	pxg.gs_team_id = t.ID and
	pxg.GS_PARTICIPANT_ID = pa.ID and
	pxg.GS_GAME_ACTIVITY_TYPE_ID = gat.ID and
	pa.GS_PLAYER_ID = pl.ID and
	g.gs_program_id = pg.ID and
	g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
	gpt.WEB_PATH = 'collectif'
$whereProgramWebPath
$whereGameWebPath
$whereTeamWebPath
$whereParticipantWebPath
								]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipantWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="participant_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="quizz_winner_participant_order_option" id="quizz_winner_participant_order_option"
						   package-name="quizz">
						<query-body>
							<!-- TODO MP : for distinct add concept of injected query: injectee -->
							<value>
								<![CDATA[
								select
									g.name game_name,
									g.web_path game_web_path,
									pg.name program_name,
									pg.web_path program_web_path,
									pl.name participant_name,
									pl.web_path participant_web_path,
									pxg.ranking ranking
								from
									gs_participant_x_game pxg,
									gs_game g,
									gs_program pg,
									gs_participant p,
									gs_player pl,
									gs_game_participation_type gpt
								where
									pxg.gs_game_id = g.ID and
									pxg.GS_PARTICIPANT_ID = p.ID and
									g.gs_program_id = pg.ID and
									p.GS_PLAYER_ID = pl.ID and
									g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
									gpt.WEB_PATH = 'individuel' and
									pxg.RANKING between 1 and 3
									and g.ID in (select g.ID from gs_participant_x_game pxg, gs_game g
										where pxg.GS_GAME_ID = g.ID and pxg.RANKING < 4 and pxg.RANKING > 0
										group by g.id
										having count(*) between 2 and 3
									)
									$whereProgramWebPath
									$whereGameWebPath
								]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="quizz_winner_team_order_option"
						   package-name="quizz">
						<query-body>
							<!-- TODO MP : for distinct add concept of injected query: injectee -->
							<value>
								<![CDATA[
select
	pg.name program_name,
    pg.web_path program_web_path,
    pg.EDITION_NUMBER,
	g.name game_name,
    g.web_path game_web_path,
    g.TIME_POSITION,
	t.name team_name,
    t.web_path team_web_path,
    txg.ranking ranking
 from
gs_team_x_game txg,
gs_game g,
gs_team t,
gs_program pg,
gs_game_participation_type gpt
where
txg.gs_game_id = g.ID and
txg.GS_TEAM_ID = t.ID and
g.gs_program_id = pg.ID and
g.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
gpt.WEB_PATH = 'collectif' and
txg.RANKING between 1 and 3
and g.ID in (select g.ID from gs_team_x_game txg, gs_game g
 	where txg.GS_GAME_ID = g.ID and txg.RANKING < 4 and txg.RANKING > 0
    group by g.id
    having count(*) between 2 and 3
 )
$whereProgramWebPath
$whereGameWebPath
								]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

				<!--  info queries -->
					<query name="team_info" id="team_info"
						   package-name="info" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
select p.name program_name, p.web_path program_web_path,
	t.name, t.web_path, t.alias, td.from_time_unit, td.to_time_unit,
	beginners.nb nb_of_beginners,
	enders.nb nb_of_enders
 from
 	gs_program p,
 	gs_team_duration td,
 	gs_team t left outer join (
 		select count(*) nb, pt.gs_team_id team_id
 		from gs_participant_team pt, gs_team t, gs_team_duration td
 		where pt.gs_team_id = t.id
 			and t.gs_team_duration_id = td.id
 			and pt.from_time_unit = td.from_time_unit
 		group by pt.gs_team_id
 	) beginners on beginners.team_id = t.id
 	left outer join (
 		select count(*) nb, pt.gs_team_id team_id
 		from gs_participant_team pt, gs_team t, gs_team_duration td
 		where pt.gs_team_id = t.id
 			and t.gs_team_duration_id = td.id
 			and pt.to_time_unit = td.to_time_unit
 		group by pt.gs_team_id
 	) enders on enders.team_id = t.id
where
	t.GS_PROGRAM_ID = p.ID and t.gs_team_duration_id = td.id
$whereProgramWebPath
$whereTeamWebPath
ORDER by edition_number asc
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="program_info" id="program_info"
						package-name="info" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
select p.name, p.web_path, p.year,
	p.EDITION_NUMBER EDITION_NUMBER,
    p.TOTAL_TIME_LENGTH,
    l.COUNTRY,
    l.COUNTRY_FLAG,
    l.COUNTRY_WEB_PATH,
    l.LATITUDE,
    l.LONGITUDE,
    winner.name winner_name,
    winner.WEB_PATH winner_web_path,
    participants.nb nb_of_participants,
    games.nb nb_of_games
 from gs_location l, gs_program p left outer join
 (
select max(nb), name, web_path, program_web_path from (
	select
		count(*) nb,
		pl.name name,
		pl.web_path web_path,
		pg.WEB_PATH program_web_path
	from gs_vote v, gs_vote_type vt, gs_participant pa, gs_player pl, gs_program pg
	where
	v.GS_VOTE_TYPE_ID = vt.ID and
	v.gs_voter_target_participant_id = pa.id and
	pa.GS_PLAYER_ID = pl.id and
	pa.GS_PROGRAM_ID = pg.ID and
	vt.web_path = 'vote-pour'
	group by pg.web_path, pl.web_path
	) yy group by program_web_path
) winner on p.web_path = winner.program_web_path,
(
	select count(*) nb, pg.WEB_PATH program_web_path from gs_participant pa, gs_program pg
	where pa.GS_PROGRAM_ID = pg.ID
	group by pg.web_path
) participants,
(
	select count(*) nb, pg.WEB_PATH program_web_path from gs_game g, gs_program pg
	where g.GS_PROGRAM_ID = pg.ID
	group by pg.web_path
) games
where
	p.GS_LOCATION_ID = l.ID and
    p.web_path = participants.program_web_path and
    p.web_path = games.program_web_path
$whereProgramWebPath
ORDER by edition_number asc
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>

						</query-filters>
					</query>
				<!--  distinct queries -->
				
				<!-- TODO query indirection 
				if query indirection : refid => no query execution
				if template is query-indirection compatible => generate
				in query-indirection-compatible template 
				
					here only rest interface
				#if ($query.isIndirection())
				
				-->
					<query name="similar_game_for_other_program" id="similar_game_for_other_program" 
						refid="distinct_games"
						package-name="distinct" content-type="master-data">
						<query-filters>
							<query-filter name="whereProgramWebPath" refid="whereNotProgramWebPath"/>
							<query-filter name="whereGameTypeWebPath" refid="whereGameTypeWebPath"/>
						</query-filters>
					</query>				
				
					<query name="distinct_games" id="distinct_games"
						package-name="distinct" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
select distinct	
	g.name name,
	g.web_path WEB_PATH,
	g.TIME_POSITION,
	g.TIME_UNIT_INDEX,
	g.PROGRAM_INDEX,
	gt.name game_type_name,
	gt.web_path game_type_web_path,
	gst.name game_stake_type_name,
	gst.web_path game_stake_type_web_path,
	p.name program_name,
	p.web_path program_web_path
from gs_game g, gs_participant_x_game pxg, gs_game_type gt, gs_game_stake_type gst, gs_program p, gs_participant pa
where
	pxg.GS_GAME_ID = g.ID and
	pxg.GS_PARTICIPANT_ID = pa.ID and
	pa.GS_PROGRAM_ID = p.ID and
	g.GS_GAME_TYPE_ID = gt.id and 
	g.GS_GAME_STAKE_TYPE_ID = gst.ID
	$whereProgramWebPath
	$whereNotProgramWebPath
	$whereGameTypeWebPath
ORDER by p.edition_number, g.PROGRAM_INDEX asc
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" id="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereNotProgramWebPath" id="whereNotProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path != ? ]]></value>
								<query-params>
									<query-param name="not_program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameTypeWebPath" id="whereGameTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gt.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
									
					<query name="distinct_programs" id="distinct_programs"
						package-name="distinct" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
SELECT p.edition_number, p.year, p.name, p.web_path, p.TOTAL_TIME_LENGTH, l.COUNTRY, l.COUNTRY_FLAG, l.COUNTRY_WEB_PATH, count(p.ID) nb_of_participants
FROM gs_program p, gs_location l, gs_participant pa
where
p.GS_LOCATION_ID = l.ID and pa.GS_PROGRAM_ID = p.ID
group by p.edition_number
ORDER by edition_number asc
]]>
							</value>
						</query-body>
					</query>
					<query name="distinct_teams" id="distinct_teams"
						package-name="distinct" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
    SELECT distinct t.name, t.web_path 
    FROM gs_team t, gs_program p 
    where t.GS_PROGRAM_ID = p.ID 
    and p.web_path = ? 
    ORDER by t.name asc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="program_web_path" type="string" sample="'378888'" size="20">
							</query-param>
						</query-params>
					</query>
					<query name="distinct_participants" id="distinct_participants"
						package-name="distinct" content-type="master-data">
						<query-body>
							<!-- duplicate code with participant_summary -->
							<value>
<![CDATA[
select pg.web_path program_web_path, pa.age, pl.name, pl.web_path, pl.family_name, pl.sex, pl.BIRTH_date, pa.final_position, xx.nb_victories, yy.max_time
from  gs_program pg, gs_player pl, gs_participant pa
left join (
select GS_PARTICIPANT_ID, count(*) nb_victories from gs_participant_x_game pxg where ranking = 1
group by GS_PARTICIPANT_ID
) xx on xx.GS_PARTICIPANT_ID = pa.id
left join (
select GS_PARTICIPANT_ID, max(TO_TIME_UNIT) max_time from GS_PARTICIPANT_TEAM pt
group by GS_PARTICIPANT_ID
) yy on yy.GS_PARTICIPANT_ID = pa.id
where pa.GS_PLAYER_ID = pl.ID
and pa.gs_program_id = pg.id
and pg.web_path = ?
ORDER by pa.final_position, pl.name asc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="program_web_path" type="string" sample="'378888'" size="20">
							</query-param>
						</query-params>
						<!-- needs a left join $whereTeamWebPath
						
						<query-filters>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						-->
					</query>
					<query name="distinct_concurrents_for_participant" id="distinct_concurrents_for_participant"
						package-name="distinct" content-type="master-data">
						<query-body>
							<value>
<![CDATA[
SELECT distinct p.name program_name, p.web_path program_web_path, pl.name, pl.web_path
FROM gs_participant pt, gs_player pl , gs_program p
where pt.GS_PROGRAM_ID = p.ID 
and pt.GS_PLAYER_ID = pl.ID
and p.ID in (
	select distinct p.id from gs_program p, gs_participant pt, gs_player pl
    where pt.GS_PROGRAM_ID = p.ID 
	and pt.GS_PLAYER_ID = pl.ID 
    and pl.WEB_PATH = ?
)
and pl.WEB_PATH != ?
ORDER by p.EDITION_NUMBER, pl.name asc
]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="player_web_path" type="string" sample="'378888'" size="20">
							</query-param>
							<query-param name="player_web_pathDup" refname="player_web_path" id="'378888'" ></query-param>
						</query-params>
					</query>

					<query name="participant_summary" id="participant_summary"
						   package-name="participant" content-type="master-data">
						<query-body>
							<value>
								<![CDATA[
select pg.web_path program_web_path, pg.name program_name, pg.EDITION_NUMBER program_EDITION_NUMBER, pa.age, pl.name, pl.web_path, pl.family_name, pl.sex, pl.BIRTH_date, pa.final_position, xx.nb_victories, yy.max_time
from  gs_program pg, gs_player pl, gs_participant pa
left join (
select GS_PARTICIPANT_ID, count(*) nb_victories from gs_participant_x_game pxg where ranking = 1
group by GS_PARTICIPANT_ID
) xx on xx.GS_PARTICIPANT_ID = pa.id
left join (
select GS_PARTICIPANT_ID, max(TO_TIME_UNIT) max_time from GS_PARTICIPANT_TEAM pt
group by GS_PARTICIPANT_ID
) yy on yy.GS_PARTICIPANT_ID = pa.id
where pa.GS_PLAYER_ID = pl.ID
and pa.gs_program_id = pg.id
$whereProgramWebPath
$wherePlayerWebPath
]]>
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pg.web_path = ? ]]></value>
								<query-params>
									<query-param
											name="program_web_path"
											display-name="program"
											type="string"
											sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherePlayerWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="get_properties" id="get_properties" package-name="property">
						<query-body>
							<value>
select 
    sp.PROPERTY property,
    sp.UNIT unit,
    s.VALUE property_value,
	s.ENTITY_TYPE entity_type,
	s.ENTITY_WEB_PATH entity_web_path
from 
	gs_ev_store s,
    gs_ev_store_property sp
where
	s.PROPERTY_ID = sp.ID and
    s.PROPERTY_ID = sp.ID 
    $whereEntityType
    $whereEntityWebPath
    $whereProperty
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereEntityType" and-where-connection="and">
								<value><![CDATA[ s.ENTITY_TYPE = ? ]]></value>
								<query-params>
									<query-param name="entity_type" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereEntityWebPath" and-where-connection="and">
								<value><![CDATA[ s.ENTITY_WEB_PATH = ? ]]></value>
								<query-params>
									<query-param name="entity_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereProperty" and-where-connection="and">
								<value><![CDATA[ sp.PROPERTY = ? ]]></value>
								<query-params>
									<query-param name="property" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<query name="participant_game_activity" id="participant_game_activity" package-name="participant">
					<!-- to replace by select * from v_sitemap order by score -->
						<query-body>
							<value>
select * from (
select
	pl.name player_name, 
    pl.web_path player_web_path,
    g.name game_name,
    g.web_path game_web_path,
    t.name team_name,
    t.WEB_PATH team_web_path,
	g.time_position,
    g.TIME_UNIT_INDEX,
    gpt.name participation_type,
    gat.name activity_type,
    pxg.ranking ranking,
    case when pxg.ranking = 0 then 99 else pxg.ranking end as display_order_asc,
    gt.name game_type_name,
    gt.WEB_PATH game_type_web_path,
    gst.name game_stake_type_name,
    gst.WEB_PATH game_stake_type_web_path,
	GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			r.name,
            r.web_path,
            r.is_positive
			)
			order by ggxr.DISPLAY_ORDER
			) rewards,
	GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			r2.name,
            r2.web_path,
            r2.is_positive
			)
			order by gxr.DISPLAY_ORDER
			) game_rewards
	,GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			x.name,
            x.web_path
			)
			order by x.DISPLAY_ORDER
			) game_tags
            
from GS_PARTICIPANT_X_GAME pxg 
		left outer join GS_PARTICIPANT_GAME_X_REWARD ggxr on ggxr.GS_PARTICIPANT_X_GAME_ID = pxg.ID
        left outer join GS_REWARD r on ggxr.GS_REWARD_ID = r.ID,
	gs_program pr, 
    gs_player pl, 
    gs_participant pa, 
    gs_team t, 
    gs_game g 
		left outer join GS_GAME_X_REWARD gxr on gxr.GS_GAME_ID = g.ID
        left outer join GS_REWARD r2 on gxr.GS_REWARD_ID = r2.ID
        left outer join (
			select GS_GAME_ID, DISPLAY_ORDER, gta.NAME, gta.WEB_PATH from GS_GAME_X_TAG gxt,  GS_GAME_TAG gta where gxt.GS_GAME_TAG_ID = gta.ID
            ) x on x.GS_GAME_ID = g.ID,
    GS_GAME_PARTICIPATION_TYPE gpt, 
    GS_GAME_ACTIVITY_TYPE gat,
    GS_GAME_STAKE_TYPE gst,
    GS_GAME_TYPE gt
where
	pxg.GS_Participant_id = pa.ID and
    pxg.GS_GAME_ID = g.ID and
    pxg.GS_TEAM_ID = t.ID and
    pxg.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
    pxg.GS_GAME_ACTIVITY_TYPE_ID = gat.ID and
	pa.GS_PROGRAM_ID = pr.ID and 
	pa.GS_PLAYER_ID = pl.ID and
    g.GS_GAME_STAKE_TYPE_ID = gst.ID and
    g.GS_GAME_TYPE_ID = gt.ID
    $whereProgramWebPath
    $wherePlayerWebPath
    $whereGameWebPath
group by pxg.ID
) xx
order by TIME_UNIT_INDEX, display_order_asc asc

							</value>
						</query-body>
						<query-fields>
							<query-field name="rewards" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="name,web_path,is_positive"
								array-columns-type="string,string,string">
							</query-field>
							<query-field name="game_rewards" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="name,web_path,is_positive"
								array-columns-type="string,string,string">
								<!--  => parts=[{eventName:"", eventWebPath:""...};{}] -->
							</query-field>
							<query-field name="game_tags" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="name,web_path"
								array-columns-type="string,string">
								<!--  => parts=[{eventName:"", eventWebPath:""...};{}] -->
							</query-field>
						</query-fields>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ pr.web_path = ? ]]></value>
								<query-params>
									<query-param 
										name="program_web_path" 
										display-name="program"
										type="string" 
										sample="'test'">
										<query-param-link  sdd-query-name="distinct_programs" 
											field-name="program_name" 
											field-key="program_web_path" 
											semantic-reference-fields="program"
											display-mode="autocomplete"
											auto-complete-min-char="1"
											auto-complete-delay="200"
											auto-complete-filter="startswith"
											 />
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherePlayerWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="participant_camp_activity" id="participant_camp_activity" package-name="participant">
					<!-- to replace by select * from v_sitemap order by score -->
						<query-body>
							<value>

select 
	prg.NAME program_name,
    prg.WEB_PATH program_web_path,
    t.NAME team_name,
    t.WEB_PATH team_web_path,
    td.FROM_TIME_UNIT team_from_time,
    td.TO_TIME_UNIT team_to_time,
	pl.name player_name, 
    pl.web_path player_web_path,
    p.ID participant_id,
    tet.NAME team_player_entrance_type,
    pt.FROM_TIME_UNIT team_player_from_time,
    tdt.NAME team_player_departure_type,
    pt.TO_TIME_UNIT team_player_to_time,
	GROUP_CONCAT(distinct
			CONCAT_WS(
			'|',
			rt.name,
            rt.web_path
			)
			order by gtxr.DISPLAY_ORDER
			) realisations
from 
	GS_PROGRAM prg,
	GS_PLAYER pl, 
	GS_PARTICIPANT p, 
	GS_PARTICIPANT_TEAM pt
		left outer join GS_PARTICIPANT_TEAM_X_REALISATION gtxr on gtxr.GS_PARTICIPANT_TEAM_ID = pt.ID
        left outer join GS_REALISATION_TYPE rt on gtxr.GS_REALISATION_TYPE_ID = rt.id, 
	GS_TEAM t, 
	GS_TEAM_DURATION td, 
	GS_TEAM_ENTRANCE_TYPE tet, 
	GS_TEAM_DEPARTURE_TYPE tdt
where 
	p.GS_PLAYER_ID = pl.ID and 
    pt.GS_PARTICIPANT_ID = p.ID and 
    p.GS_PROGRAM_ID = prg.ID and
    pt.GS_TEAM_ID = t.ID and 
    t.GS_TEAM_DURATION_ID = td.ID and
    pt.GS_TEAM_ENTRANCE_TYPE_ID = tet.ID and 
    pt.GS_TEAM_DEPARTURE_TYPE_ID = tdt.ID
    $whereProgramWebPath
    $whereTeamWebPath
    $wherePlayerWebPath
group by pt.ID
order by pl.name, td.FROM_TIME_UNIT
							</value>
						</query-body>
						<query-fields>
							<query-field name="realisations" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="name,web_path"
								array-columns-type="string,string">
							</query-field>
						</query-fields>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ prg.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="wherePlayerWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					<query name="vote_detail" id="vote_detail" package-name="vote">
						<query-body>
							<value>
select 
	v.id,
	p.name program_name,
	p.web_path program_web_path,
	t.name team_name,	
	t.web_path team_web_path,
	vt.name vote_type_name,
	vt.web_path vote_type_web_path,
	vet.name vote_effectiveness_type_name,
	vet.web_path vote_effectiveness_type_web_path,
	pl1.name voter_name,
	pl1.web_path voter_web_path,
	pl2.name voter_target_name,
	pl2.web_path voter_target_web_path,
	v.sequence,
	v.time_unit,
	v.vote_number 
from 
	gs_vote v,
	gs_team t,
	gs_program p,
	gs_participant p1,
	gs_player pl1,
	gs_participant p2,
	gs_player pl2,
	gs_vote_effectiveness_type vet,
	gs_vote_type vt
where
	v.gs_vote_effectiveness_type_id = vet.id and
	v.gs_vote_type_id = vt.id and
	v.gs_team_id = t.id and
	t.gs_program_id = p.id and
	v.gs_voter_participant_id = p1.id and
	p1.gs_player_id = pl1.id and
	v.gs_voter_target_participant_id = p2.id and
	p2.gs_player_id = pl2.id
    $whereProgramWebPath
    $whereTeamWebPath
    $whereVoterWebPath	
    $whereVoterTargetWebPath
    $whereeffectivenesstypeWebPath
    $whereetypeWebPath
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereVoterWebPath" and-where-connection="and">
								<value><![CDATA[ pl1.web_path = ? ]]></value>
								<query-params>
									<query-param name="voter_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereVoterTargetWebPath" and-where-connection="and">
								<value><![CDATA[ pl2.web_path = ? ]]></value>
								<query-params>
									<query-param name="voter_target_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereeffectivenesstypeWebPath" and-where-connection="and">
								<value><![CDATA[ vet.web_path = ? ]]></value>
								<query-params>
									<query-param name="vote_effectiveness_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereetypeWebPath" and-where-connection="and">
								<value><![CDATA[ vt.web_path = ? ]]></value>
								<query-params>
									<query-param name="vote_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>
					
					<!-- timeline -->
					<query name="team_game_timeline" id="team_game_timeline" package-name="timeline">
						<query-body>
							<value>
select 
	p.name program_name,
	p.web_path program_web_path,
    t.name team_name,
    t.WEB_PATH team_web_path,
    g.name game_name,
	g.web_path game_web_path,
    GROUP_CONCAT(distinct
				CONCAT_WS(
				'|',
				pl.WEB_PATH,
                pl.NAME,
                pxg.RANKING
				)
				order by pl.NAME
				) team_details,
	count(pl.WEB_PATH) nb_players,
    xxx.nb_teams,
    case when xxx.winner_team_id = t.id then 1 else 0 end is_winner,
    xxx.winner_team_web_path,
    xxx.winner_participant_web_paths,
	g.program_index program_index,
    g.TIME_POSITION TIME_POSITION,
	gt.name game_type_name,
	gt.web_path game_type_web_path,
	gst.name game_stake_type_name,
	gst.web_path game_stake_type_web_path,
	gpt.name participation_type_name,
	gpt.web_path participation_type_web_path
	from gs_game g, gs_team t, gs_participant_x_game pxg, gs_game_type gt, gs_game_stake_type gst, gs_program p, gs_participant pa, gs_player pl, GS_GAME_PARTICIPATION_TYPE gpt, GS_GAME_ACTIVITY_TYPE gat
	, (    
 select 
 aaa.nb_teams nb_teams,
 aaa.program_id,
 aaa.game_id,
 winner_team.team_id winner_team_id,
 winner_team.team_web_path winner_team_web_path,
 winner_participant.players winner_participant_web_paths
 from 
 (
   select count(distinct t.ID) nb_teams, p.ID program_id, g.PROGRAM_INDEX, g.id game_id
 from  gs_team t, gs_game g, gs_participant_x_game pxg, gs_program p
 where t.GS_PROGRAM_ID = p.ID and pxg.gs_team_id = t.id and pxg.GS_GAME_ID = g.ID
 group by program_id, g.PROGRAM_INDEX
 ) aaa,
 (
   select distinct t.ID team_id, t.WEB_PATH team_web_path, g.ID game_id, PROGRAM_INDEX
 from  gs_team t, gs_game g, gs_participant_x_game pxg, gs_program p
 where t.GS_PROGRAM_ID = p.ID and pxg.gs_team_id = t.id and pxg.GS_GAME_ID = g.ID
 and pxg.ranking = 1
 ) winner_team,
  (
   select 
       GROUP_CONCAT(distinct
				CONCAT_WS(
				'|',
				pl.WEB_PATH,
                pl.NAME
				)
				order by pl.NAME
				) players,
   g.ID game_id, PROGRAM_INDEX
 from  gs_participant pa, gs_player pl, gs_game g, gs_participant_x_game pxg
 where pxg.GS_PARTICIPANT_ID = pa.id and pa.gs_player_id = pl.id and pxg.GS_GAME_ID = g.ID
 and pxg.ranking = 1
 group by g.id
 ) winner_participant
 where aaa.game_id = winner_team.game_id 
 and aaa.game_id = winner_participant.game_id
    ) xxx
    where
	pxg.GS_GAME_ID = g.ID and
    pxg.GS_TEAM_ID = t.ID and
	pxg.GS_PARTICIPANT_ID = pa.ID and
	pa.GS_PROGRAM_ID = p.ID and
	g.GS_GAME_TYPE_ID = gt.id and 
	g.GS_GAME_STAKE_TYPE_ID = gst.ID and
	pa.GS_PLAYER_ID = pl.ID and
    pxg.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
    pxg.GS_GAME_ACTIVITY_TYPE_ID = gat.ID and 
    xxx.game_id = g.id
    $whereProgramWebPath
    $whereTeamWebPath 
    $whereParticipantWebPath
    $whereGameWebPath
    $whereGameTypeWebPath
 group by team_web_path, program_index, game_web_path
 order by p.name, program_index, t.name, g.name, pl.name
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gt.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipantWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-fields>
							<query-field name="team_details" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="participant_web_path,participant_name,ranking"
								array-columns-type="string,string,int">
							</query-field>
							<query-field name="winner_participant_web_paths" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="participant_web_path,participant_name"
								array-columns-type="string,string">
							</query-field>
						</query-fields>
					</query>
					
					<query name="team_participant_timeline" id="team_participant_timeline" package-name="timeline">
						<query-body>
							<value>
select 
*
from
(
select  
	pxt.id,
    pr.WEB_PATH program_web_path,
	t.name team_name,
	t.web_path team_web_path,
	td.FROM_TIME_UNIT team_from_time,
    td.TO_TIME_UNIT team_to_time,
    pxt.FROM_TIME_UNIT time_unit,
    pl.NAME participant_name,
    pl.WEB_PATH participant_web_path,
	'entrance' event_type,
    tet.NAME event_type_name,
    tet.WEB_PATH event_type_web_path
from 
	gs_team t,
    gs_program pr,
	gs_team_duration td,
    gs_participant_team pxt,
    gs_participant p,
    gs_player pl,
    gs_team_entrance_type tet
where
	pxt.GS_PARTICIPANT_ID = p.ID and
    t.GS_PROGRAM_ID = pr.id and
    t.GS_TEAM_DURATION_ID= td.ID and
    pxt.GS_TEAM_ID = t.ID and
	p.GS_PLAYER_ID = pl.ID and
    pxt.GS_TEAM_ENTRANCE_TYPE_ID = tet.ID 
union
select  
	pxt.id,
    pr.WEB_PATH program_web_path,
	t.name team_name,
	t.web_path team_web_path,
    td.FROM_TIME_UNIT team_from_time,
    td.TO_TIME_UNIT team_to_time,
    pxt.TO_TIME_UNIT time_unit,
    pl.NAME participant_name,
    pl.WEB_PATH participant_web_path,
	'departure' event_type,
    tdt.NAME event_type_name,
    tdt.WEB_PATH event_type_web_path
from 
	gs_team t,
    gs_program pr,
    gs_team_duration td,
    gs_participant_team pxt,
    gs_participant p,
    gs_player pl,
    gs_team_departure_type tdt
where
	pxt.GS_PARTICIPANT_ID = p.ID and
    t.GS_PROGRAM_ID = pr.id and
    t.GS_TEAM_DURATION_ID= td.ID and
    pxt.GS_TEAM_ID = t.ID and
	p.GS_PLAYER_ID = pl.ID and
    pxt.GS_TEAM_DEPARTURE_TYPE_ID = tdt.ID 
    
    ) xx
    $whereProgramWebPath
    $whereTeamWebPath
    $whereParticipantWebPath
order by time_unit asc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="where">
								<value><![CDATA[ xx.program_web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="where">
								<value><![CDATA[ xx.team_web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipantWebPath" and-where-connection="where">
								<value><![CDATA[ xx.participant_web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
					</query>

					<!-- stats -->
					<query name="game_stats" id="game_stats" package-name="stat">

						<query-body>
							<value>
select
participant_name,
participant_web_path,
program_name,
program_web_path,
sum(totem) totems,
sum(totem_individual) totems_individual,
sum(confort) conforts,
sum(confort_individual) conforts_individual,
sum(ranking_1)  ranking_1,
sum(ranking_2)  ranking_2,
sum(ranking_3)  ranking_3,
sum(ranking_other) ranking_other,
sum(ranking_1_alone)  ranking_1_alone,
sum(ranking_2_alone)  ranking_2_alone,
sum(ranking_3_alone)  ranking_3_alone,
sum(ranking_other_alone) ranking_other_alone,
count(distinct game_name) nb_of_games,
sum(individual_game_last) individual_game_lasts,
sum(active_participantion) active_participations,
sum(individual_game) individual_participations,
GROUP_CONCAT(distinct
				CONCAT_WS(
				'|',
				game_name,
                game_web_path,
                program_index,
				activity_type_name,
                participation_type_name,
                game_stake_type_name,
                ranking
				)
				order by program_index
				) participation_details
from (
	select 	
	pl.name participant_name,
	pl.WEB_PATH participant_web_path,
	pxg.RANKING ranking,
	case when pxg.RANKING = 1 then 1 else 0 end ranking_1,
	case when pxg.RANKING = 2 then 1 else 0 end ranking_2,
	case when pxg.RANKING = 3 then 1 else 0 end ranking_3,
     case when pxg.RANKING > 3 or pxg.RANKING = 0 then 1 else 0 end ranking_other,
	case when pxg.RANKING = 1 and gpt.WEB_PATH = 'individuel' then 1 else 0 end ranking_1_alone,
	case when pxg.RANKING = 2 and gpt.WEB_PATH = 'individuel' then 1 else 0 end ranking_2_alone,
	case when pxg.RANKING = 3 and gpt.WEB_PATH = 'individuel' then 1 else 0 end ranking_3_alone,
    case when (pxg.RANKING > 3 or pxg.RANKING = 0) and gpt.WEB_PATH = 'individuel' then 1 else 0 end ranking_other_alone,
    case when gst.WEB_PATH = 'immunite' and pxg.ranking = 1 then 1 else 0 end totem,
    case when gst.web_path= 'immunite' and gpt.WEB_PATH = 'individuel' and pxg.ranking = 1 then 1 else 0 end totem_individual,
	case when gst.WEB_PATH = 'confort' and pxg.ranking = 1 then 1 else 0 end confort,
    case when gst.web_path = 'confort' and gpt.WEB_PATH = 'individuel' and pxg.ranking = 1 then 1 else 0 end confort_individual,
    case when gpt.WEB_PATH = 'individuel' then 1 else 0 end individual_game,
    case when gpt.WEB_PATH = 'individuel' and max_ranking=pxg.ranking and nb_register_participants=pxg.ranking then 1 else 0 end individual_game_last,
    case when gat.web_path = 'participant' then 1 else 0 end active_participantion,
    gat.name activity_type_name, gat.web_path activity_type_web_path,
	g.program_index program_index,
	g.name game_name,
	g.web_path game_web_path,
	gt.name game_type_name,
	gt.web_path game_type_web_path,
	gst.name game_stake_type_name,
	gst.web_path game_stake_type_web_path,
	gpt.name participation_type_name,
	gpt.web_path participation_type_web_path,
	p.name program_name,
	p.web_path program_web_path
	from gs_game g, gs_team t, gs_participant_x_game pxg, gs_game_type gt, gs_game_stake_type gst, gs_program p, gs_participant pa, gs_player pl, GS_GAME_PARTICIPATION_TYPE gpt, GS_GAME_ACTIVITY_TYPE gat
		, (    
		select max(pxg.ranking) max_ranking, count(*) nb_register_participants, g.id from gs_game g, gs_participant_x_game pxg
			where
		pxg.GS_GAME_ID = g.ID 
		group by g.id
		order by g.id
    ) aaa
    where
	pxg.GS_GAME_ID = g.ID and
	pxg.gs_team_id = t.id and
	pxg.GS_PARTICIPANT_ID = pa.ID and
	pa.GS_PROGRAM_ID = p.ID and
	g.GS_GAME_TYPE_ID = gt.id and 
	g.GS_GAME_STAKE_TYPE_ID = gst.ID and
	pa.GS_PLAYER_ID = pl.ID and
    pxg.GS_GAME_PARTICIPATION_TYPE_ID = gpt.ID and
    pxg.GS_GAME_ACTIVITY_TYPE_ID = gat.ID and
    aaa.id = g.id
    $whereProgramWebPath
    $whereParticipantWebPath
    $whereGameWebPath
    $whereTeamWebPath
    $whereGameTypeWebPath
    $whereGameStakeTypeWebPath
    $whereGameParticipationTypeWebPath
    $whereGameActivityTypeWebPath
) xxx

group by 
participant_name,
participant_web_path,
program_name,
program_web_path
order by
ranking_1 desc, ranking_2 desc, ranking_3 desc
							</value>
						</query-body>
						<query-filters>
							<query-filter name="whereProgramWebPath" and-where-connection="and">
								<value><![CDATA[ p.web_path = ? ]]></value>
								<query-params>
									<query-param name="program_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereParticipantWebPath" and-where-connection="and">
								<value><![CDATA[ pl.web_path = ? ]]></value>
								<query-params>
									<query-param name="player_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameWebPath" and-where-connection="and">
								<value><![CDATA[ g.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereTeamWebPath" and-where-connection="and">
								<value><![CDATA[ t.web_path = ? ]]></value>
								<query-params>
									<query-param name="team_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>							
							<query-filter name="whereGameTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gt.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameStakeTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gst.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_stake_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameParticipationTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gpt.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_participation_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
							<query-filter name="whereGameActivityTypeWebPath" and-where-connection="and">
								<value><![CDATA[ gat.web_path = ? ]]></value>
								<query-params>
									<query-param name="game_activity_type_web_path" type="string" sample="'test'">
									</query-param>
								</query-params>
							</query-filter>
						</query-filters>
						<query-fields>
						<!-- 
						                program_index,activity_type_name,game_name,participation_type_name,game_stake_type_name,ranking
						 -->
							<query-field name="participation_details" 
								is-structured-array="true" 
								separator-characters=",|"
								array-columns="game_name,game_web_path,program_index,activity_type_name,participation_type_name,game_stake_type_name,ranking"
								array-columns-type="string,string,intstring,string,string,int">
							</query-field>
						</query-fields>
					</query>
				
					<!-- write queries -->
					<query name="create_game_participation" id="create_game_participation"
						package-name="game" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call create_game_participation (?, ?, ?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="participant_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="game_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="activity_type_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="participation_type_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="ranking" is-mandatory="true" type="int"
								sample="1">
							</query-param>
							<query-param name="reward_web_paths" is-mandatory="true" type="string"
								sample="'win,reward2'"></query-param>
						</query-params>
					</query>

					<!-- vote -->
					<query name="first_vote_against" id="first_vote_against"
						package-name="vote" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call first_vote_against (?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="voter_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="voter_target_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="time_unit" is-mandatory="true" type="int"
								sample="1">
							</query-param>
							<query-param name="vote_effectiveness_type_web_path" is-mandatory="true" type="string"
								sample="'effectif'"></query-param>
						</query-params>
					</query>
					
					<query name="second_vote_against" id="first_vote_against"
						package-name="vote" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call second_vote_against (?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="voter_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="voter_target_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="time_unit" is-mandatory="true" type="int"
								sample="1">
							</query-param>
							<query-param name="vote_effectiveness_type_web_path" is-mandatory="true" type="string"
								sample="'effectif'"></query-param>
						</query-params>
					</query>
					
					<!-- team activity -->
					<query name="create_participant_entrance" id="create_participant_entrance"
						package-name="team" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call create_participant_entrance (?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="participant_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="from_time" is-mandatory="true" type="int"
								sample="10">
							</query-param>
							<query-param name="entrance_type_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="participant_team_id" is-output-param="true" type="int"
								sample="10"></query-param>
						</query-params>
					</query>
					<query name="create_participant_departure" id="create_participant_departure"
						package-name="team" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call create_participant_departure (?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="participant_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="to_time" is-mandatory="true" type="int"
								sample="10">
							</query-param>
							<query-param name="departure_type_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="participant_team_id" is-output-param="true" type="int"
								sample="10"></query-param>
						</query-params>
					</query>
					<query name="create_participant_realisation" id="create_participant_realisation"
						package-name="team" is-write="true">
						<query-body>
							<value>
<![CDATA[
	call create_participant_realisation (?, ?, ?, ?, ?)
	]]>
							</value>
						</query-body>
						<query-params>
							<query-param name="participant_web_path" is-mandatory="true" type="string"
								sample="'win'">
							</query-param>
							<query-param name="team_web_path" is-mandatory="true" type="string"
								sample="'team1'">
							</query-param>
							<query-param name="time" is-mandatory="true" type="int"
								sample="10">
							</query-param>
							<query-param name="realisation_web_path" is-mandatory="true" type="string"
								sample="'game1'">
							</query-param>
							<query-param name="participant_team_realisation_id" is-output-param="true" type="int"
								sample="10"></query-param>
						</query-params>
					</query>
				</queries>	
				<composites>
					<composite name="participant_camp_activity_info" id="participant_camp_activity_info"
						package-name="info">
						<queries>
						<!-- -->
							<query refid="participant_camp_activity" result-cardinality="many" holder="false"></query>
						 
							<query refid="distinct_programs" result-cardinality="many" holder="false"></query>
							<query refid="distinct_teams" result-cardinality="many" holder="false"></query>
							<query refid="distinct_participants" result-cardinality="many" holder="false"></query>
						</queries>
						
						<composite-params>

							<query-param name="program_web_path" is-mandatory="true"
								type="'prg'" sample="'test'" is-id="true"></query-param>
							<query-param name="team_web_path" is-mandatory="false"
								type="'prg'" sample="'test'" is-id="true"></query-param>
							<query-param name="participant_web_path" is-mandatory="false"
								type="'prg'" sample="'test'" is-id="true"></query-param>
						</composite-params>
						<!--  -->
					</composite>
					<composite name="participant_detail" id="participant_detail"
						package-name="participant">
						<queries>
						<!-- 4 each program 
						
							 participant summary:
							 Name, Firstname, webpath, nb victoires, nb jours , position, age, sex
							  -->
							<!--  distinct_participants should be relative to user and not program -->
							<!--<query refid="distinct_concurrents_for_participant" result-cardinality="many" holder="false"></query>
							-->
							<query refid="distinct_participants" result-cardinality="many" holder="false"></query>
							<query refid="participant_summary" result-cardinality="many" holder="false"></query>

							<query refid="game_stats" result-cardinality="many" holder="false"></query>
							<query refid="get_properties" result-cardinality="many" holder="false"></query>						 
							<query refid="participant_game_activity" result-cardinality="many" holder="false"></query>						 
							<query refid="participant_camp_activity" result-cardinality="many" holder="false"></query>
							<query refid="team_participant_timeline" result-cardinality="many" holder="false"></query>
						</queries>
						
						<composite-params>
							<query-param name="player_web_path" is-mandatory="true"
								type="'prg'" sample="'test'" is-id="true"></query-param>
								<!-- TODO for explicit param add also default="" -->
						</composite-params>
						<!-- TODO group by program_web_path -->
					</composite>
					<composite name="game_detail" id="game_detail" package-name="game">
						<queries>						 
							<query refid="get_properties" result-cardinality="one" holder="false">
								<!-- TODO query-params -->
								<query-params>
									<query-param name="entity_type" value="game"/>
									<query-param name="entity_web_path" refid="game_web_path"/>
								</query-params>
							</query>						 
							<query refid="participant_game_activity" result-cardinality="one" holder="false"></query>
							<query refid="distinct_games" result-cardinality="one" holder="false"></query>
							<query refid="game_stats" result-cardinality="many" holder="false"></query>
							<query refid="program_info" result-cardinality="one" holder="false"></query>
							<!-- 
							<query refid="similar_game_for_other_program" name="similar_game_for_other_program" result-cardinality="one" holder="false"></query>
							 -->
						</queries>
						<composite-params>
							<query-param name="game_web_path" id="game_web_path" is-mandatory="true"
								type="'game'" sample="'test'" is-id="true"></query-param>
								<!-- TODO for explicit param add also default="" -->
						</composite-params>
						<!-- TODO group by program_web_path -->
					</composite>

					<composite name="team_detail" id="team_detail" package-name="team">
						<queries>						 
							<query refid="get_properties" result-cardinality="one" holder="false">
								<!-- TODO query-params -->
								<query-params>
									<query-param name="entity_type" value="team"/>
									<query-param name="entity_web_path" refid="team_web_path"/>
								</query-params>
							</query>						 
							<query refid="team_participant_timeline" result-cardinality="many" holder="false"></query>
							<query refid="team_game_timeline" result-cardinality="many" holder="false"></query>
							<query refid="game_stats" result-cardinality="many" holder="false"></query>
							<query refid="team_info" result-cardinality="one"></query>
							<query refid="program_info" result-cardinality="one" holder="false"></query>

						</queries>
						<composite-params>
							<query-param name="game_web_path" id="game_web_path" is-mandatory="true"
								type="'game'" sample="'test'" is-id="true"></query-param>
								<!-- TODO for explicit param add also default="" -->
						</composite-params>
						<!-- TODO group by program_web_path -->
					</composite>
					

					<composite name="program_detail" id="program_detail" package-name="program">
						<queries>						 
							<query refid="get_properties" result-cardinality="one" holder="false">
								<!-- TODO query-params -->
								<query-params>
									<query-param name="entity_type" value="program"/>
									<query-param name="entity_web_path" refid="program_web_path"/>
								</query-params>
							</query>						 
							<query refid="distinct_programs" result-cardinality="one" holder="false"></query>
							<query refid="program_info" result-cardinality="one" holder="false"></query>		
							<query refid="participant_game_activity" result-cardinality="one" holder="false"></query>
							<query refid="participant_camp_activity" result-cardinality="many" holder="false"></query>
							<query refid="team_participant_timeline" result-cardinality="many" holder="false"></query>							
							<query refid="team_game_timeline" result-cardinality="many" holder="false"></query>
							<query refid="game_stats" result-cardinality="many" holder="false"></query>
						</queries>
						<composite-params>
							<query-param name="program_web_path" id="program_web_path" is-mandatory="true"
								type="'game'" sample="'test'" is-id="true"></query-param>
								<!-- TODO for explicit param add also default="" -->
						</composite-params>
						<!-- TODO group by program_web_path -->
					</composite>
					
				</composites>		
			</statement-model>
		</model>

		<targets catalog-entry="REST-Kendoui, Ember"
			append-catalog-entry-dir-to-outputdir-root="true"
			outputdir-root="../../product/game-score-public-api">

			<property name="openxava-disable-sdd" value="true" />
			<property name="environment" value="remote" />
			<property name="show-sql" value="false" />

			<property name="filter-cors" value="apache" />
			<property name="swagger" value="true" />
			<property name="botdetect" value="true" />
			<property name="setter-return-instance" value="true" />
			<property name="add-named-queries" value="false" />

			<property name="target-server" value="tomcat" />

			<property name="embedded-datasource" value="docker">
				<property name="jdbcUrl" value="jdbc:mysql://db:3306/kohlantstats?connectTimeout=0&amp;socketTimeout=0&amp;autoReconnect=true"/>
				<property name="username" value="root"/>
				<property name="password" value="P@ssw0rd"/>
			</property>
			<!-- -->
			<property name="mail-server" value="mailgun">
				<property name="mail.smtps.host" value="smtp.mailgun.org" />
				<property name="mail.smtps.auth" value="true" />
				<property name="mail.smtp.socketFactory.class" value="javax.net.ssl.SSLSocketFactory" />
				<property name="mail.smtp.starttls.enable" value="true" />
				<property name="mail.smtp.ssl.trust" value="smtp.mailgun.org" />

				<property name="username" value="postmaster@winerylabs.com" />
				<property name="password" value="5155c8411cb29829e715462bbd3cf878" />
				<property name="url" value="smtp.mailgun.com" />
			</property>

			<property name="maven-dependencies">
				<property name="gson"
					value="group: 'com.google.code.gson', name: 'gson', version: '2.2.4'" />
				<property name="jbcrypt"
					value="group: 'org.mindrot', name: 'jbcrypt', version: '0.4'" />
				<property name="velocity"
					value="group: 'org.apache.velocity', name: 'velocity', version: '1.7'" />
				<property name="velocity-tools"
					value="group: 'org.apache.velocity', name: 'velocity-tools', version: '2.0'" />
				<property name="velocity-tools"
					value="group: 'org.json', name: 'json', version: '20190722'" />
				<property name="itextpdf"
					value="group: 'com.itextpdf', name: 'itextpdf', version: '5.5.13'" />
				<property name="itextpdf-xmlworker"
					value="group: 'com.itextpdf.tool', name: 'xmlworker', version: '5.5.13'" />
				<!-- <property name="javax.mail" value="group: 'javax.mail', name: 'mail', 
					version: '1.5.0-b01'"/> -->
			</property>

			<property name="disable-sass-maven-plugin" value="true" />
			<property name="maven-artifact-finalName-suffix" value="PublicApi" />

		</targets>


	</configuration>
</generator-config>

