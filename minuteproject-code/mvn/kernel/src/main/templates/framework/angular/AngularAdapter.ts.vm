#exposeAngularModelSpecific()
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
## import appendQuery from 'append-query';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

##import {${modelAngularBaseAdapterClass}} from '@/${modelAngularBaseAdapterImport}';
import * as model from '../../${modelTypescriptSchemaImport}';##TODO solve relative path

@Injectable({ providedIn: 'root' })
export default class ${className} {##extends ${modelAngularBaseAdapterClass} {

	baseUrl = 'todo';

	httpOptions = {
		headers: new HttpHeaders({ 'Content-Type': 'application/json' })
	};

	constructor(
		private http: HttpClient
	) { }

	private handleError<T>(operation = 'operation', result?: T) {
		return (error: any): Observable<T> => {

			// TODO: send the error to remote logging infrastructure
			console.error(error); // log to console instead

			// TODO: better job of transforming error for user consumption
			this.log(`${operation} failed: ${error.message}`);

			// Let the app keep running by returning an empty result.
			return of(result as T);
		};
	}

	private log(message:string) {
		//TODO
	}

#foreach ($package in $model.getStatementModel().getSddPackage().getQueryPackages())
    //package $package.name
#foreach ($query in $package.getQueries())
#if(!$query.isIndirection())
#if(!$queryUtils.isBackend($query))
#if (!$query.isWrite())##TODO with POST
##if($query.queryParams.hasOutputParam()) ##other with http.post
#exposeAngularQuerySpecific()
#set($table=$query.inputBean)
#exposeVariableEntitySpecific()
#putImportSDDInputBean()
    /* connector to $domainClassName info */
    ${tableVariableName} (params:model.${sddInputBeanClass}):Observable<model.${sddOutputBeanClass}[]> {
		const p = new HttpParams({fromObject: params});
##return this.http.get<model.${sddOutputBeanClass}[]>(`${this.baseUrl}/data/sdd/${sddInputBeanClass}`+filter${domainClassName}(params))
		return this.http.get<model.${sddOutputBeanClass}W>(`${this.baseUrl}/data/sdd/${sddInputBeanClass}`,{params: p})
			.pipe(
				tap(_ => this.log('fetched ${sddOutputBeanClass}')),
//				catchError(this.handleError<model.${sddOutputBeanClass}[]>('${sddOutputBeanClass}', []))
			);
    }
#* temporary remove pivot
#foreach ($pivot in $query.pivots)
#set($pivotClass = $formatUtils.firstUpperCase($pivot.name))
#set($pivotClasses = $i18nUtils.plurialize($pivotClass))
	/* pivot $pivotClass */
	${tableVariableName}Get${pivotClasses} (params:model.${pivotClass}):Observable<model.${sddOutputBeanClass}[]> {
##		return fetchData(this.baseUrl+'/data/sdd/${sddInputBeanClass}/get${pivotClasses}'+filter${domainClassName}(params));
		return this.http.get<model.$tableClassName$pivotClass []>(`${this.baseUrl}/data/sdd/${sddInputBeanClass}/get${pivotClasses}`+filter${domainClassName}(params))
				.pipe(
						tap(_ => this.log('fetched $tableClassName$pivotClass')),
						catchError(this.handleError<model.$tableClassName$pivotClass []>('$tableClassName$pivotClass', []))
				);
	}
#end

 *#
#end
#end
#end
#end
#end
##end


}

#* do no handle composite yet
#foreach ($package in $model.getStatementModel().getSddPackage().getQueryPackages())
#foreach ($composite in $package.getComposites())
#exposeCompositeSpecific()
#set($functionName = $emberUtils.getComponentClassPath(${classVariableName}))
#set ($functionVariableName = $formatUtils.firstLowerCase(${functionName}))
/* filter for composite $className entity */
function filter${functionVariableName} (filter:model.${sddInputBeanClass}) {
	if (filter) {
		return appendQuery("",{
#foreach($column in ${composite.distinctInputColumn})
#putColumnParamNaming()
				"$columnVar":filter.$columnVar #if($velocityCount!=$size),
#end
#end
				}, 
				{ removeNull: true }
			);
	}
	return "";
}			

#end
#end

 *#

#* remove appender

#foreach ($package in $model.getStatementModel().getSddPackage().getQueryPackages())
//$package.name
#foreach ($query in $package.getQueries())
#if(!$query.isIndirection())
#if (!$queryUtils.isBackend($query))
#if (!$query.isWrite())##TODO with POST
#exposeQuerySpecific()
#set($table=$query.inputBean)
#set($tableLabel=$i18nUtils.getI18nFromDBObject($table))
#exposeVariableEntitySpecific()
#putImportSDDInputBean()
/* filter for $domainClassName entity */
function filter${domainClassName} (filter:model.${sddInputBeanClass}) {
	if (filter) {
		return appendQuery("",{
#foreach($column in $inputBean.columns)
#if (!$column.hasBeenDuplicated())
#putColumnParamNaming()
				"$columnVar":filter.$columnVar,
#end
#end
#foreach($queryChunk in $query.getQueryChunks())
#set($chunkName=$javaUtils.getJavaVariableNaming($queryChunk.name))
				"$chunkName":filter.$chunkName,	//Allowed values $queryChunk.getDistinctValues()
#end
				}, 
				{ removeNull: true }
			);
	}
	return "";
}			
#end
#end
#end
#end
#end

*#

